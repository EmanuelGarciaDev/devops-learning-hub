{
  "id": "advanced-git",
  "toolId": "git",
  "name": "Advanced Git Techniques",
  "description": "Master advanced Git operations including rebasing, cherry-picking, submodules, and repository maintenance",
  "difficulty": "advanced",
  "definitions": {
    "beginner": "Advanced Git techniques help you manipulate commit history, work with complex repository structures, and maintain clean project histories. These include rebasing commits, cherry-picking specific changes, and managing submodules.",
    "advanced": "Advanced Git operations leverage the underlying DAG structure to perform sophisticated history manipulation, implement complex workflow patterns, and optimize repository performance. This includes interactive rebasing for commit curation, cherry-picking for selective change application, submodule management for modular architectures, and repository maintenance through garbage collection and object optimization."
  },
  "commands": [
    {
      "command": "git rebase",
      "description": "Reapply commits on top of another base tip",
      "example": "git rebase -i HEAD~3",
      "flags": [
        {
          "flag": "-i",
          "description": "Interactive rebase for editing commits",
          "example": "-i HEAD~5"
        },
        {
          "flag": "--onto",
          "description": "Rebase onto specific commit",
          "example": "--onto main feature~3 feature"
        },
        {
          "flag": "--preserve-merges",
          "description": "Preserve merge commits during rebase",
          "example": "--preserve-merges"
        },
        {
          "flag": "--exec",
          "description": "Execute command after each commit",
          "example": "--exec 'npm test'"
        }
      ]
    },
    {
      "command": "git cherry-pick",
      "description": "Apply changes from specific commits",
      "example": "git cherry-pick abc123 def456",
      "flags": [
        {
          "flag": "-n",
          "description": "Don't commit automatically",
          "example": "-n"
        },
        {
          "flag": "-x",
          "description": "Add source commit reference",
          "example": "-x"
        },
        {
          "flag": "--strategy",
          "description": "Use specific merge strategy",
          "example": "--strategy=recursive -X theirs"
        }
      ]
    },
    {
      "command": "git submodule",
      "description": "Manage Git submodules",
      "example": "git submodule add https://github.com/user/lib.git lib",
      "flags": [
        {
          "flag": "add",
          "description": "Add new submodule",
          "example": "add https://github.com/user/repo.git path"
        },
        {
          "flag": "update",
          "description": "Update submodules",
          "example": "update --init --recursive"
        },
        {
          "flag": "foreach",
          "description": "Execute command in each submodule",
          "example": "foreach 'git pull origin main'"
        }
      ]
    },
    {
      "command": "git worktree",
      "description": "Manage multiple working trees",
      "example": "git worktree add ../feature-branch feature",
      "flags": [
        {
          "flag": "add",
          "description": "Add new working tree",
          "example": "add ../hotfix hotfix/security-patch"
        },
        {
          "flag": "list",
          "description": "List working trees",
          "example": "list"
        },
        {
          "flag": "remove",
          "description": "Remove working tree",
          "example": "remove ../feature-branch"
        }
      ]
    },
    {
      "command": "git bisect",
      "description": "Binary search to find bug introduction",
      "example": "git bisect start HEAD v1.0",
      "flags": [
        {
          "flag": "start",
          "description": "Start bisect session",
          "example": "start <bad> <good>"
        },
        {
          "flag": "good",
          "description": "Mark current commit as good",
          "example": "good"
        },
        {
          "flag": "bad",
          "description": "Mark current commit as bad",
          "example": "bad"
        },
        {
          "flag": "run",
          "description": "Automate bisect with script",
          "example": "run ./test-script.sh"
        }
      ]
    },
    {
      "command": "git reflog",
      "description": "Show reference logs",
      "example": "git reflog show HEAD",
      "flags": [
        {
          "flag": "show",
          "description": "Show reflog for reference",
          "example": "show main"
        },
        {
          "flag": "--all",
          "description": "Show all reference logs",
          "example": "--all"
        },
        {
          "flag": "expire",
          "description": "Expire reflog entries",
          "example": "expire --expire=90.days.ago --all"
        }
      ]
    }
  ],
  "examples": [
    {
      "title": "Interactive Rebase for Commit History Cleanup",
      "description": "Advanced interactive rebasing techniques for maintaining clean commit history",
      "code": "#!/bin/bash\n# Interactive Rebase and Commit History Management\n# Demonstrates advanced techniques for clean commit history\n\necho \"=== Interactive Rebase Demo ===\"\nmkdir rebase-demo\ncd rebase-demo\ngit init\n\n# Create initial project with messy commit history\necho \"Setting up project with messy commits...\"\n\n# Initial commit\ncat > README.md << 'EOF'\n# Advanced Git Demo Project\n\nDemonstrating interactive rebase and history cleanup.\nEOF\n\ncat > app.js << 'EOF'\nconsole.log('Hello, World!');\nEOF\n\ngit add .\ngit commit -m \"Initial commit\"\n\n# Create a series of messy commits that need cleanup\necho \"\\n// Add user greeting\" >> app.js\ngit add app.js\ngit commit -m \"add greeting\"\n\necho \"const userName = 'Developer';\" >> app.js\ngit add app.js\ngit commit -m \"WIP: working on greeting\"\n\necho \"console.log(\\`Hello, \\${userName}!\\`);\" >> app.js\ngit add app.js\ngit commit -m \"fix greeting function\"\n\necho \"\\n// TODO: Add more features\" >> app.js\ngit add app.js\ngit commit -m \"add todo\"\n\necho \"# Installation\\n\\nRun \\`npm install\\` to get started.\" >> README.md\ngit add README.md\ngit commit -m \"update readme\"\n\necho \"\\n# Usage\\n\\nRun \\`node app.js\\` to start.\" >> README.md\ngit add README.md\ngit commit -m \"more readme updates\"\n\necho \"const fs = require('fs');\" > app.js\ncat >> app.js << 'EOF'\n\n// Configuration\nconst config = {\n  userName: process.env.USER_NAME || 'Developer',\n  greeting: 'Hello',\n  debug: process.env.NODE_ENV === 'development'\n};\n\n// Main application\nfunction greetUser() {\n  const message = `${config.greeting}, ${config.userName}!`;\n  \n  if (config.debug) {\n    console.log('Debug: Greeting user with config:', config);\n  }\n  \n  console.log(message);\n}\n\n// Error handling\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  process.exit(1);\n});\n\n// Start application\nif (require.main === module) {\n  greetUser();\n}\n\nmodule.exports = { greetUser, config };\nEOF\n\ngit add app.js\ngit commit -m \"major refactor of greeting system\"\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"advanced-git-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Demo project for advanced Git techniques\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"NODE_ENV=development node app.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\"git\", \"demo\", \"rebase\"],\n  \"author\": \"Developer\",\n  \"license\": \"MIT\"\n}\nEOF\n\ngit add package.json\ngit commit -m \"add package.json\"\n\necho \"\\n=== Before Rebase - Messy Commit History ===\"\ngit log --oneline\n\n# Now demonstrate interactive rebase\necho \"\\n=== Interactive Rebase Process ===\"\necho \"We have 8 commits that need cleanup:\"\necho \"1. Initial commit (keep as-is)\"\necho \"2-4. Greeting-related commits (squash together)\"\necho \"5. TODO comment (drop - not needed)\"\necho \"6-7. README updates (squash together)\"\necho \"8-9. Major refactor and package.json (keep separate)\"\n\n# Create rebase script for automation (in real scenario, this would be interactive)\ncat > rebase-commands.txt << 'EOF'\npick a1b2c3d Initial commit\npick e4f5g6h add greeting\nsquash i7j8k9l WIP: working on greeting\nsquash m1n2o3p fix greeting function\ndrop q4r5s6t add todo\npick u7v8w9x update readme\nsquash y1z2a3b more readme updates\npick c4d5e6f major refactor of greeting system\npick g7h8i9j add package.json\nEOF\n\necho \"\\nRebase commands that would be used:\"\ncat rebase-commands.txt\n\n# Manual rebase simulation (showing the concept)\necho \"\\n=== Simulating Interactive Rebase Results ===\"\n\n# Reset to demonstrate clean history\ngit reset --hard HEAD~8\n\n# Recreate with clean commits\ncat > README.md << 'EOF'\n# Advanced Git Demo Project\n\nDemonstrating interactive rebase and history cleanup.\n\n# Installation\n\nRun `npm install` to get started.\n\n# Usage\n\nRun `node app.js` to start.\nEOF\n\ncat > app.js << 'EOF'\nconst fs = require('fs');\n\n// Configuration\nconst config = {\n  userName: process.env.USER_NAME || 'Developer',\n  greeting: 'Hello',\n  debug: process.env.NODE_ENV === 'development'\n};\n\n// Main application\nfunction greetUser() {\n  const message = `${config.greeting}, ${config.userName}!`;\n  \n  if (config.debug) {\n    console.log('Debug: Greeting user with config:', config);\n  }\n  \n  console.log(message);\n}\n\n// Error handling\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  process.exit(1);\n});\n\n// Start application\nif (require.main === module) {\n  greetUser();\n}\n\nmodule.exports = { greetUser, config };\nEOF\n\ngit add .\ngit commit -m \"Initial commit: Project setup with structure\"\n\ngit add .\ngit commit -m \"Implement user greeting system\n\n- Add configurable greeting functionality\n- Support environment-based configuration\n- Include debug logging capabilities\n- Add proper error handling\"\n\ngit add .\ngit commit -m \"Add project documentation and usage instructions\n\n- Document installation process\n- Add usage examples\n- Include project description\"\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"advanced-git-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Demo project for advanced Git techniques\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"NODE_ENV=development node app.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\"git\", \"demo\", \"rebase\"],\n  \"author\": \"Developer\",\n  \"license\": \"MIT\"\n}\nEOF\n\ngit add package.json\ngit commit -m \"Add package.json with project metadata and scripts\"\n\necho \"\\n=== After Rebase - Clean Commit History ===\"\ngit log --oneline\n\necho \"\\n=== Advanced Rebase Techniques ===\"\n\n# Demonstrate rebase with exec\necho \"\\nRebasing with automatic testing:\"\necho \"git rebase -i HEAD~3 --exec 'npm test'\"\necho \"This would run 'npm test' after each commit during rebase\"\n\n# Demonstrate rebase onto\necho \"\\nRebasing onto specific commit:\"\ngit checkout -b feature/new-functionality\necho \"function newFeature() { console.log('New feature!'); }\" >> app.js\ngit add app.js\ngit commit -m \"Add new feature function\"\n\necho \"module.exports.newFeature = newFeature;\" >> app.js\ngit add app.js\ngit commit -m \"Export new feature\"\n\ngit checkout main\necho \"\\n// Updated main branch\" >> README.md\ngit add README.md\ngit commit -m \"Update main branch\"\n\necho \"\\nBefore rebase onto main:\"\ngit log --oneline --graph --all\n\ngit checkout feature/new-functionality\necho \"git rebase --onto main HEAD~2\"\necho \"This would rebase the last 2 commits onto main\"\n\necho \"\\n=== Commit Message Rewriting ===\"\n\n# Demonstrate commit message editing\necho \"\\nRewriting commit messages with rebase:\"\necho \"During interactive rebase, use 'reword' to edit commit messages:\"\ncat << 'EOF'\n# Original commits:\ncommit abc123 \"fix bug\"\ncommit def456 \"add stuff\"\ncommit ghi789 \"update thing\"\n\n# After reword:\ncommit abc123 \"Fix critical authentication bug in login controller\"\ncommit def456 \"Add comprehensive input validation for user forms\"\ncommit ghi789 \"Update API documentation with new endpoint examples\"\nEOF\n\necho \"\\n=== Squash vs Fixup ===\"\necho \"\\nSquash: Combines commits and allows editing the commit message\"\necho \"Fixup: Combines commits and discards the fixup commit message\"\necho \"\\nExample rebase commands:\"\ncat << 'EOF'\npick abc123 Add user authentication\nfixup def456 Fix typo in auth function\nfixup ghi789 Add missing semicolon\nsquash jkl012 Add password validation\nsquash mno345 Update validation tests\nEOF\n\necho \"\\n=== Best Practices for Interactive Rebase ===\"\ncat << 'EOF'\n1. **Never rebase commits that have been pushed to shared branches**\n   - Only rebase local commits or feature branches\n   - Use --force-with-lease for safer force pushes\n\n2. **Keep commits atomic and logical**\n   - Each commit should represent one logical change\n   - Combine related changes, separate unrelated ones\n\n3. **Write clear commit messages**\n   - Use reword to improve commit message clarity\n   - Follow conventional commit format when appropriate\n\n4. **Test after rebasing**\n   - Use --exec to run tests during rebase\n   - Verify functionality after history changes\n\n5. **Backup before complex rebases**\n   - Create backup branch: git branch backup-branch\n   - Use reflog to recover if needed\nEOF\n\necho \"\\n✅ Interactive rebase demonstration completed!\"",
      "language": "bash",
      "scenario": "Comprehensive interactive rebase techniques for commit history management"
    },
    {
      "title": "Cherry-picking and Selective Change Application",
      "description": "Advanced cherry-picking techniques for applying specific changes across branches",
      "code": "#!/bin/bash\n# Cherry-picking and Selective Change Application\n# Demonstrates advanced techniques for applying specific commits\n\necho \"=== Cherry-picking Demo ===\"\nmkdir cherry-pick-demo\ncd cherry-pick-demo\ngit init\n\n# Set up main branch with initial structure\necho \"Setting up main branch...\"\ncat > README.md << 'EOF'\n# Multi-feature Application\n\nDemonstrating cherry-picking techniques.\nEOF\n\ncat > app.js << 'EOF'\n// Main application\nconsole.log('Application starting...');\n\nclass App {\n  constructor() {\n    this.version = '1.0.0';\n    this.features = [];\n  }\n  \n  start() {\n    console.log(`App version ${this.version} started`);\n  }\n}\n\nconst app = new App();\napp.start();\n\nmodule.exports = App;\nEOF\n\ngit add .\ngit commit -m \"Initial application structure\"\n\n# Create development branch with multiple features\necho \"\\n=== Creating Development Branch ===\"\ngit checkout -b development\n\n# Feature 1: User management\ncat >> app.js << 'EOF'\n\n// User Management Feature\nclass UserManager {\n  constructor() {\n    this.users = new Map();\n  }\n  \n  addUser(id, userData) {\n    if (this.users.has(id)) {\n      throw new Error(`User ${id} already exists`);\n    }\n    \n    const user = {\n      id,\n      ...userData,\n      createdAt: new Date(),\n      isActive: true\n    };\n    \n    this.users.set(id, user);\n    console.log(`User ${id} added successfully`);\n    return user;\n  }\n  \n  getUser(id) {\n    return this.users.get(id);\n  }\n  \n  removeUser(id) {\n    if (!this.users.has(id)) {\n      throw new Error(`User ${id} not found`);\n    }\n    \n    this.users.delete(id);\n    console.log(`User ${id} removed`);\n  }\n  \n  listUsers() {\n    return Array.from(this.users.values());\n  }\n}\nEOF\n\ngit add app.js\ngit commit -m \"Add user management system\n\n- Implement UserManager class\n- Add CRUD operations for users\n- Include error handling and validation\n- Add user lifecycle management\"\n\n# Feature 2: Logging system\ncat >> app.js << 'EOF'\n\n// Logging System\nclass Logger {\n  constructor(level = 'info') {\n    this.level = level;\n    this.levels = {\n      'error': 0,\n      'warn': 1,\n      'info': 2,\n      'debug': 3\n    };\n  }\n  \n  log(level, message, data = null) {\n    if (this.levels[level] <= this.levels[this.level]) {\n      const timestamp = new Date().toISOString();\n      const logEntry = {\n        timestamp,\n        level: level.toUpperCase(),\n        message,\n        data\n      };\n      \n      console.log(`[${logEntry.timestamp}] ${logEntry.level}: ${logEntry.message}`);\n      if (data) {\n        console.log('Data:', JSON.stringify(data, null, 2));\n      }\n    }\n  }\n  \n  error(message, data) { this.log('error', message, data); }\n  warn(message, data) { this.log('warn', message, data); }\n  info(message, data) { this.log('info', message, data); }\n  debug(message, data) { this.log('debug', message, data); }\n}\nEOF\n\ngit add app.js\ngit commit -m \"Implement comprehensive logging system\n\n- Add Logger class with multiple levels\n- Support structured logging with timestamps\n- Include data serialization for complex objects\n- Add level-based filtering\"\n\n# Feature 3: Configuration management\ncat >> app.js << 'EOF'\n\n// Configuration Management\nclass ConfigManager {\n  constructor() {\n    this.config = new Map();\n    this.defaults = {\n      'app.name': 'Multi-feature Application',\n      'app.version': '1.0.0',\n      'logging.level': 'info',\n      'user.maxSessions': 10,\n      'database.host': 'localhost',\n      'database.port': 5432\n    };\n    \n    // Load defaults\n    for (const [key, value] of Object.entries(this.defaults)) {\n      this.config.set(key, value);\n    }\n  }\n  \n  get(key, defaultValue = null) {\n    return this.config.get(key) ?? defaultValue;\n  }\n  \n  set(key, value) {\n    this.config.set(key, value);\n    console.log(`Configuration updated: ${key} = ${value}`);\n  }\n  \n  has(key) {\n    return this.config.has(key);\n  }\n  \n  reset(key) {\n    if (this.defaults.hasOwnProperty(key)) {\n      this.config.set(key, this.defaults[key]);\n    } else {\n      this.config.delete(key);\n    }\n  }\n  \n  getAll() {\n    return Object.fromEntries(this.config);\n  }\n}\nEOF\n\ngit add app.js\ngit commit -m \"Add configuration management system\n\n- Implement ConfigManager with defaults\n- Support get/set/reset operations\n- Add configuration validation\n- Include environment-based overrides\"\n\n# Bug fix commit\nsed -i 's/this.version = .1.0.0./this.version = .1.0.1./' app.js\ngit add app.js\ngit commit -m \"Fix version number in App class\"\n\n# Feature 4: Database connection (will have issues)\ncat >> app.js << 'EOF'\n\n// Database Connection (with intentional bug)\nclass DatabaseManager {\n  constructor(config) {\n    this.config = config;\n    this.connection = null;\n    this.isConnected = false;\n  }\n  \n  async connect() {\n    try {\n      console.log('Connecting to database...');\n      // Simulate connection\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      this.connection = {\n        host: this.config.get('database.host'),\n        port: this.config.get('database.port'),\n        connected: true\n      };\n      \n      this.isConnected = true;\n      console.log('Database connected successfully');\n    } catch (error) {\n      console.error('Database connection failed:', error);\n      throw error;\n    }\n  }\n  \n  async disconnect() {\n    if (this.isConnected) {\n      this.connection = null;\n      this.isConnected = false;\n      console.log('Database disconnected');\n    }\n  }\n  \n  async query(sql, params = []) {\n    if (!this.isConnected) {\n      throw new Error('Database not connected');\n    }\n    \n    console.log(`Executing query: ${sql}`);\n    // Simulate query execution\n    return { rows: [], count: 0 };\n  }\n}\nEOF\n\ngit add app.js\ngit commit -m \"Add database connection manager\n\n- Implement DatabaseManager class\n- Add connection lifecycle management\n- Support parameterized queries\n- Include error handling\"\n\necho \"\\n=== Development Branch History ===\"\ngit log --oneline\n\n# Now create different branches that need specific features\necho \"\\n=== Creating Release Branches ===\"\n\n# Release branch that needs only user management and logging\ngit checkout main\ngit checkout -b release/user-features\n\necho \"Cherry-picking user management and logging features...\"\n\n# Get commit hashes (in real scenario, you'd use actual hashes)\nUSER_COMMIT=$(git log development --oneline | grep \"user management\" | cut -d' ' -f1)\nLOGGING_COMMIT=$(git log development --oneline | grep \"logging system\" | cut -d' ' -f1)\nBUG_FIX_COMMIT=$(git log development --oneline | grep \"Fix version\" | cut -d' ' -f1)\n\necho \"\\nCherry-picking specific commits:\"\necho \"git cherry-pick $USER_COMMIT\"    # User management\necho \"git cherry-pick $LOGGING_COMMIT\" # Logging system  \necho \"git cherry-pick $BUG_FIX_COMMIT\" # Bug fix\n\n# Simulate cherry-pick results\ncat > app.js << 'EOF'\n// Main application\nconsole.log('Application starting...');\n\nclass App {\n  constructor() {\n    this.version = '1.0.1';  // Bug fix applied\n    this.features = [];\n  }\n  \n  start() {\n    console.log(`App version ${this.version} started`);\n  }\n}\n\nconst app = new App();\napp.start();\n\nmodule.exports = App;\n\n// User Management Feature (cherry-picked)\nclass UserManager {\n  constructor() {\n    this.users = new Map();\n  }\n  \n  addUser(id, userData) {\n    if (this.users.has(id)) {\n      throw new Error(`User ${id} already exists`);\n    }\n    \n    const user = {\n      id,\n      ...userData,\n      createdAt: new Date(),\n      isActive: true\n    };\n    \n    this.users.set(id, user);\n    console.log(`User ${id} added successfully`);\n    return user;\n  }\n  \n  getUser(id) {\n    return this.users.get(id);\n  }\n  \n  removeUser(id) {\n    if (!this.users.has(id)) {\n      throw new Error(`User ${id} not found`);\n    }\n    \n    this.users.delete(id);\n    console.log(`User ${id} removed`);\n  }\n  \n  listUsers() {\n    return Array.from(this.users.values());\n  }\n}\n\n// Logging System (cherry-picked)\nclass Logger {\n  constructor(level = 'info') {\n    this.level = level;\n    this.levels = {\n      'error': 0,\n      'warn': 1,\n      'info': 2,\n      'debug': 3\n    };\n  }\n  \n  log(level, message, data = null) {\n    if (this.levels[level] <= this.levels[this.level]) {\n      const timestamp = new Date().toISOString();\n      const logEntry = {\n        timestamp,\n        level: level.toUpperCase(),\n        message,\n        data\n      };\n      \n      console.log(`[${logEntry.timestamp}] ${logEntry.level}: ${logEntry.message}`);\n      if (data) {\n        console.log('Data:', JSON.stringify(data, null, 2));\n      }\n    }\n  }\n  \n  error(message, data) { this.log('error', message, data); }\n  warn(message, data) { this.log('warn', message, data); }\n  info(message, data) { this.log('info', message, data); }\n  debug(message, data) { this.log('debug', message, data); }\n}\nEOF\n\ngit add app.js\ngit commit -m \"Cherry-pick: Add user management and logging systems\n\nCherry-picked commits:\n- User management system\n- Comprehensive logging\n- Version number bug fix\n\nExcludes:\n- Configuration management (not needed for this release)\n- Database manager (has known issues)\"\n\necho \"\\n=== Advanced Cherry-picking Techniques ===\"\n\n# Cherry-pick with strategy\necho \"\\nCherry-picking with merge strategy:\"\necho \"git cherry-pick -X theirs abc123\"  # Use their version for conflicts\necho \"git cherry-pick -X ours def456\"   # Use our version for conflicts\n\n# Cherry-pick range\necho \"\\nCherry-picking commit range:\"\necho \"git cherry-pick abc123..def456\"   # Range of commits\necho \"git cherry-pick abc123^..def456\"  # Include abc123 in range\n\n# Cherry-pick without committing\necho \"\\nCherry-picking without auto-commit:\"\necho \"git cherry-pick -n abc123\"        # Stage changes but don't commit\necho \"# Allows manual review and modification before committing\"\n\n# Multiple cherry-picks\necho \"\\nCherry-picking multiple commits:\"\necho \"git cherry-pick abc123 def456 ghi789\"  # Multiple specific commits\n\necho \"\\n=== Handling Cherry-pick Conflicts ===\"\n\n# Create conflict scenario\ngit checkout main\ngit checkout -b hotfix/urgent-fix\n\n# Modify the same area that will conflict\nsed -i 's/console.log(.Application starting...);/console.log(\"Application starting with hotfix...\");/' app.js\ngit add app.js\ngit commit -m \"Hotfix: Update startup message\"\n\n# Now try to cherry-pick a commit that modifies the same area\necho \"\\nSimulating cherry-pick conflict:\"\necho \"git cherry-pick $LOGGING_COMMIT\"\necho \"\\nConflict resolution process:\"\ncat << 'EOF'\n1. Git will pause and show conflict markers:\n   <<<<<<< HEAD\n   console.log(\"Application starting with hotfix...\");\n   =======\n   console.log('Application starting...');\n   >>>>>>> abc123... Implement comprehensive logging system\n\n2. Resolve conflicts manually:\n   - Edit file to combine changes appropriately\n   - Remove conflict markers\n   - Test the resolution\n\n3. Continue cherry-pick:\n   git add resolved-file.js\n   git cherry-pick --continue\n\n4. Or abort if needed:\n   git cherry-pick --abort\nEOF\n\necho \"\\n=== Cherry-pick Best Practices ===\"\ncat << 'EOF'\n1. **Use -x flag for tracking**\n   git cherry-pick -x abc123\n   # Adds \"(cherry picked from commit abc123)\" to commit message\n\n2. **Cherry-pick bug fixes first**\n   # Apply critical fixes to release branches immediately\n   git cherry-pick hotfix-commit\n\n3. **Avoid cherry-picking merge commits**\n   # Use -m flag if necessary:\n   git cherry-pick -m 1 merge-commit\n\n4. **Test after cherry-picking**\n   # Ensure functionality works in new context\n   npm test\n\n5. **Document cherry-picked commits**\n   # Maintain clear history of what was cherry-picked where\n\n6. **Consider rebase vs cherry-pick**\n   # Rebase: Moving entire branch\n   # Cherry-pick: Selective commit application\nEOF\n\necho \"\\n=== Cherry-pick vs Merge vs Rebase ===\"\ncat << 'EOF'\n| Operation   | Use Case                    | History Impact     |\n|-------------|-----------------------------|--------------------|  \n| Cherry-pick | Selective commit copying    | Creates new commits|\n| Merge       | Combining branch histories  | Preserves context  |\n| Rebase      | Linear history maintenance  | Rewrites history   |\n\nCherry-pick Examples:\n- Applying hotfixes to release branches\n- Backporting features to older versions\n- Applying specific commits to different environments\n- Excluding problematic commits during integration\nEOF\n\necho \"\\n=== Repository State Summary ===\"\necho \"Main branch: Basic application structure\"\necho \"Development branch: All features + bug fixes\"\necho \"Release/user-features: Selective features via cherry-pick\"\necho \"Hotfix branch: Urgent fixes\"\n\necho \"\\n✅ Cherry-picking demonstration completed!\"\necho \"\\n📝 Key takeaways:\"\necho \"- Cherry-pick allows selective commit application\"\necho \"- Use -x flag for traceability\"\necho \"- Handle conflicts carefully\"\necho \"- Test thoroughly after cherry-picking\"\necho \"- Document cherry-picked changes\"",
      "language": "bash",
      "scenario": "Advanced cherry-picking techniques for selective change application across branches"
    },
    {
      "title": "Git Submodules and Repository Composition",
      "description": "Managing complex projects with Git submodules for modular architecture",
      "code": "#!/bin/bash\n# Git Submodules and Repository Composition\n# Demonstrates advanced submodule management for modular projects\n\necho \"=== Git Submodules Demo ===\"\n\n# Create main project repository\nmkdir main-project\ncd main-project\ngit init\n\necho \"Setting up main project...\"\ncat > README.md << 'EOF'\n# Modular Application Platform\n\nA comprehensive platform built with modular architecture using Git submodules.\n\n## Architecture\n\n```\nmain-project/\n├── src/\n│   ├── core/           # Main application code\n│   └── modules/\n│       ├── auth/       # Authentication module (submodule)\n│       ├── ui/         # UI components library (submodule)\n│       └── utils/      # Utility functions (submodule)\n├── libs/\n│   ├── database/       # Database abstraction layer (submodule)\n│   └── logging/        # Logging library (submodule)\n└── docs/              # Documentation (submodule)\n```\n\n## Development Setup\n\n1. Clone with submodules:\n   ```bash\n   git clone --recursive https://github.com/company/main-project.git\n   ```\n\n2. Initialize submodules (if not cloned recursively):\n   ```bash\n   git submodule update --init --recursive\n   ```\n\n3. Update all submodules:\n   ```bash\n   git submodule update --remote\n   ```\nEOF\n\n# Create main application structure\nmkdir -p src/{core,modules} libs docs\n\ncat > src/core/app.js << 'EOF'\n// Main application entry point\nconst auth = require('../modules/auth');\nconst ui = require('../modules/ui');\nconst utils = require('../modules/utils');\nconst database = require('../../libs/database');\nconst logger = require('../../libs/logging');\n\nclass Application {\n  constructor() {\n    this.logger = new logger.Logger('app');\n    this.db = new database.DatabaseManager();\n    this.auth = new auth.AuthManager();\n    this.ui = new ui.UIManager();\n  }\n  \n  async initialize() {\n    this.logger.info('Initializing application...');\n    \n    try {\n      await this.db.connect();\n      await this.auth.initialize();\n      await this.ui.initialize();\n      \n      this.logger.info('Application initialized successfully');\n    } catch (error) {\n      this.logger.error('Application initialization failed:', error);\n      throw error;\n    }\n  }\n  \n  async start() {\n    await this.initialize();\n    this.logger.info('Application started');\n  }\n}\n\nmodule.exports = Application;\nEOF\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"modular-application-platform\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Platform demonstrating Git submodule management\",\n  \"main\": \"src/core/app.js\",\n  \"scripts\": {\n    \"start\": \"node src/core/app.js\",\n    \"dev\": \"nodemon src/core/app.js\",\n    \"test\": \"npm run test:core && npm run test:modules\",\n    \"test:core\": \"jest src/core\",\n    \"test:modules\": \"git submodule foreach 'npm test'\",\n    \"update-submodules\": \"git submodule update --remote\",\n    \"init-submodules\": \"git submodule update --init --recursive\",\n    \"status-all\": \"git status && git submodule foreach 'git status'\",\n    \"pull-all\": \"git pull && git submodule foreach 'git pull origin main'\"\n  },\n  \"keywords\": [\"modular\", \"submodules\", \"architecture\"],\n  \"author\": \"Development Team\",\n  \"license\": \"MIT\"\n}\nEOF\n\ngit add .\ngit commit -m \"Initial main project setup\n\n- Add modular application structure\n- Create main application entry point\n- Set up package.json with submodule scripts\n- Add comprehensive documentation\"\n\necho \"\\n=== Creating Submodule Repositories ===\"\n\n# Create separate repositories for each submodule\ncd ..\n\n# 1. Authentication Module\necho \"Creating authentication module...\"\nmkdir auth-module\ncd auth-module\ngit init\n\ncat > index.js << 'EOF'\n// Authentication Module\nclass AuthManager {\n  constructor() {\n    this.users = new Map();\n    this.sessions = new Map();\n  }\n  \n  async initialize() {\n    console.log('Auth module initialized');\n  }\n  \n  async authenticate(username, password) {\n    // Mock authentication\n    const user = this.users.get(username);\n    if (user && user.password === password) {\n      const sessionId = this.generateSessionId();\n      this.sessions.set(sessionId, { username, createdAt: new Date() });\n      return { success: true, sessionId };\n    }\n    return { success: false, error: 'Invalid credentials' };\n  }\n  \n  generateSessionId() {\n    return Math.random().toString(36).substr(2, 16);\n  }\n  \n  validateSession(sessionId) {\n    return this.sessions.has(sessionId);\n  }\n}\n\nmodule.exports = { AuthManager };\nEOF\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"auth-module\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Authentication module for modular platform\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"jest\"\n  },\n  \"keywords\": [\"auth\", \"authentication\", \"module\"],\n  \"license\": \"MIT\"\n}\nEOF\n\ncat > README.md << 'EOF'\n# Authentication Module\n\nProvides authentication and session management for the main platform.\n\n## Features\n- User authentication\n- Session management\n- Security validation\n\n## Usage\n\n```javascript\nconst { AuthManager } = require('./index');\nconst auth = new AuthManager();\n\nawait auth.initialize();\nconst result = await auth.authenticate('user', 'password');\n```\nEOF\n\ngit add .\ngit commit -m \"Initial auth module implementation\"\n\n# 2. UI Components Library\ncd ..\necho \"Creating UI components library...\"\nmkdir ui-components\ncd ui-components\ngit init\n\ncat > index.js << 'EOF'\n// UI Components Library\nclass UIManager {\n  constructor() {\n    this.components = new Map();\n  }\n  \n  async initialize() {\n    console.log('UI module initialized');\n    this.registerComponents();\n  }\n  \n  registerComponents() {\n    this.components.set('button', Button);\n    this.components.set('input', Input);\n    this.components.set('modal', Modal);\n  }\n  \n  createComponent(type, props) {\n    const Component = this.components.get(type);\n    if (!Component) {\n      throw new Error(`Unknown component type: ${type}`);\n    }\n    return new Component(props);\n  }\n}\n\nclass Button {\n  constructor(props) {\n    this.text = props.text || 'Button';\n    this.onClick = props.onClick || (() => {});\n  }\n  \n  render() {\n    return `<button onclick=\"${this.onClick}\">${this.text}</button>`;\n  }\n}\n\nclass Input {\n  constructor(props) {\n    this.type = props.type || 'text';\n    this.placeholder = props.placeholder || '';\n    this.value = props.value || '';\n  }\n  \n  render() {\n    return `<input type=\"${this.type}\" placeholder=\"${this.placeholder}\" value=\"${this.value}\">`;\n  }\n}\n\nclass Modal {\n  constructor(props) {\n    this.title = props.title || 'Modal';\n    this.content = props.content || '';\n  }\n  \n  render() {\n    return `\n      <div class=\"modal\">\n        <div class=\"modal-header\">\n          <h2>${this.title}</h2>\n        </div>\n        <div class=\"modal-content\">\n          ${this.content}\n        </div>\n      </div>\n    `;\n  }\n}\n\nmodule.exports = { UIManager, Button, Input, Modal };\nEOF\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"ui-components\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Reusable UI components library\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"build\": \"webpack\"\n  },\n  \"keywords\": [\"ui\", \"components\", \"library\"],\n  \"license\": \"MIT\"\n}\nEOF\n\ngit add .\ngit commit -m \"Initial UI components library\"\n\n# 3. Database Library\ncd ..\necho \"Creating database library...\"\nmkdir database-lib\ncd database-lib\ngit init\n\ncat > index.js << 'EOF'\n// Database Abstraction Library\nclass DatabaseManager {\n  constructor(config = {}) {\n    this.config = {\n      host: config.host || 'localhost',\n      port: config.port || 5432,\n      database: config.database || 'app_db',\n      ...config\n    };\n    this.connection = null;\n  }\n  \n  async connect() {\n    console.log(`Connecting to database at ${this.config.host}:${this.config.port}`);\n    // Mock connection\n    this.connection = {\n      connected: true,\n      host: this.config.host,\n      port: this.config.port\n    };\n    console.log('Database connected successfully');\n  }\n  \n  async disconnect() {\n    if (this.connection) {\n      this.connection = null;\n      console.log('Database disconnected');\n    }\n  }\n  \n  async query(sql, params = []) {\n    if (!this.connection) {\n      throw new Error('Database not connected');\n    }\n    \n    console.log(`Executing query: ${sql}`);\n    if (params.length > 0) {\n      console.log('Parameters:', params);\n    }\n    \n    // Mock query result\n    return {\n      rows: [],\n      rowCount: 0,\n      command: sql.split(' ')[0].toUpperCase()\n    };\n  }\n}\n\nmodule.exports = { DatabaseManager };\nEOF\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"database-lib\",\n  \"version\": \"2.1.0\",\n  \"description\": \"Database abstraction layer\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"jest\"\n  },\n  \"keywords\": [\"database\", \"abstraction\", \"sql\"],\n  \"license\": \"MIT\"\n}\nEOF\n\ngit add .\ngit commit -m \"Initial database abstraction library\"\n\n# 4. Logging Library\ncd ..\necho \"Creating logging library...\"\nmkdir logging-lib\ncd logging-lib\ngit init\n\ncat > index.js << 'EOF'\n// Advanced Logging Library\nclass Logger {\n  constructor(module = 'app') {\n    this.module = module;\n    this.levels = {\n      'error': 0,\n      'warn': 1,\n      'info': 2,\n      'debug': 3\n    };\n    this.currentLevel = 'info';\n  }\n  \n  setLevel(level) {\n    if (this.levels.hasOwnProperty(level)) {\n      this.currentLevel = level;\n    }\n  }\n  \n  log(level, message, data = null) {\n    if (this.levels[level] <= this.levels[this.currentLevel]) {\n      const timestamp = new Date().toISOString();\n      const logEntry = `[${timestamp}] [${this.module}] ${level.toUpperCase()}: ${message}`;\n      \n      console.log(logEntry);\n      if (data) {\n        console.log('Data:', JSON.stringify(data, null, 2));\n      }\n    }\n  }\n  \n  error(message, data) { this.log('error', message, data); }\n  warn(message, data) { this.log('warn', message, data); }\n  info(message, data) { this.log('info', message, data); }\n  debug(message, data) { this.log('debug', message, data); }\n}\n\nmodule.exports = { Logger };\nEOF\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"logging-lib\",\n  \"version\": \"1.5.0\",\n  \"description\": \"Advanced logging library with multiple levels\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"jest\"\n  },\n  \"keywords\": [\"logging\", \"debug\", \"monitoring\"],\n  \"license\": \"MIT\"\n}\nEOF\n\ngit add .\ngit commit -m \"Initial logging library implementation\"\n\necho \"\\n=== Adding Submodules to Main Project ===\"\ncd ../main-project\n\n# Add submodules\necho \"Adding authentication module...\"\ngit submodule add ../auth-module src/modules/auth\n\necho \"Adding UI components library...\"\ngit submodule add ../ui-components src/modules/ui\n\necho \"Adding database library...\"\ngit submodule add ../database-lib libs/database\n\necho \"Adding logging library...\"\ngit submodule add ../logging-lib libs/logging\n\n# Create .gitmodules file content will be auto-generated\necho \"\\nGenerated .gitmodules file:\"\ncat .gitmodules\n\n# Commit submodule additions\ngit add .\ngit commit -m \"Add submodules for modular architecture\n\n- Add authentication module (src/modules/auth)\n- Add UI components library (src/modules/ui)  \n- Add database abstraction layer (libs/database)\n- Add logging library (libs/logging)\n\nAll submodules are tracked and versioned independently.\"\n\necho \"\\n=== Submodule Management Commands ===\"\n\n# Show submodule status\necho \"\\nSubmodule status:\"\ngit submodule status\n\n# Update specific submodule\necho \"\\nUpdating specific submodule:\"\necho \"git submodule update src/modules/auth\"\n\n# Update all submodules to latest\necho \"\\nUpdating all submodules to latest:\"\necho \"git submodule update --remote\"\n\n# Initialize submodules in fresh clone\necho \"\\nInitializing submodules in fresh clone:\"\necho \"git submodule update --init --recursive\"\n\necho \"\\n=== Advanced Submodule Operations ===\"\n\n# Working with submodule changes\necho \"\\nMaking changes in submodule:\"\ncd src/modules/auth\necho \"\\n// Added new feature\" >> index.js\ngit add index.js\ngit commit -m \"Add new authentication feature\"\n\n# Return to main project\ncd ../../..\n\necho \"\\nSubmodule status after changes:\"\ngit submodule status\necho \"\\nNotice the '+' indicating uncommitted changes in main project\"\n\n# Update main project to track new submodule commit\necho \"\\nUpdating main project to track new submodule version:\"\ngit add src/modules/auth\ngit commit -m \"Update auth module to latest version with new features\"\n\necho \"\\n=== Submodule Workflows ===\"\n\n# Create script for common submodule operations\ncat > scripts/submodule-helpers.sh << 'EOF'\n#!/bin/bash\n# Submodule Helper Scripts\n\n# Function to update all submodules\nupdate_all_submodules() {\n  echo \"Updating all submodules to latest...\"\n  git submodule update --remote\n  git add .\n  git commit -m \"Update all submodules to latest versions\"\n}\n\n# Function to check submodule status\ncheck_submodule_status() {\n  echo \"=== Submodule Status ===\"\n  git submodule status\n  \n  echo \"\\n=== Submodule Summary ===\"\n  git submodule summary\n}\n\n# Function to execute command in all submodules\nexec_in_submodules() {\n  local command=\"$1\"\n  echo \"Executing '$command' in all submodules...\"\n  git submodule foreach \"$command\"\n}\n\n# Function to pull latest in all submodules\npull_all_submodules() {\n  echo \"Pulling latest changes in all submodules...\"\n  git submodule foreach 'git pull origin main'\n}\n\n# Function to create feature branch in submodule\ncreate_submodule_feature() {\n  local submodule_path=\"$1\"\n  local branch_name=\"$2\"\n  \n  if [ -z \"$submodule_path\" ] || [ -z \"$branch_name\" ]; then\n    echo \"Usage: create_submodule_feature <submodule_path> <branch_name>\"\n    return 1\n  fi\n  \n  echo \"Creating feature branch '$branch_name' in submodule '$submodule_path'...\"\n  cd \"$submodule_path\"\n  git checkout -b \"$branch_name\"\n  cd - > /dev/null\n}\n\n# Function to sync submodule with upstream\nsync_submodule_upstream() {\n  local submodule_path=\"$1\"\n  \n  if [ -z \"$submodule_path\" ]; then\n    echo \"Usage: sync_submodule_upstream <submodule_path>\"\n    return 1\n  fi\n  \n  echo \"Syncing submodule '$submodule_path' with upstream...\"\n  cd \"$submodule_path\"\n  git fetch upstream\n  git checkout main\n  git merge upstream/main\n  git push origin main\n  cd - > /dev/null\n}\n\n# Export functions\nexport -f update_all_submodules\nexport -f check_submodule_status\nexport -f exec_in_submodules\nexport -f pull_all_submodules\nexport -f create_submodule_feature\nexport -f sync_submodule_upstream\n\necho \"Submodule helper functions loaded:\"\necho \"- update_all_submodules\"\necho \"- check_submodule_status\"\necho \"- exec_in_submodules <command>\"\necho \"- pull_all_submodules\"\necho \"- create_submodule_feature <path> <branch>\"\necho \"- sync_submodule_upstream <path>\"\nEOF\n\nchmod +x scripts/submodule-helpers.sh\n\n# Add npm scripts for submodule management\ncat > package.json << 'EOF'\n{\n  \"name\": \"modular-application-platform\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Platform demonstrating Git submodule management\",\n  \"main\": \"src/core/app.js\",\n  \"scripts\": {\n    \"start\": \"node src/core/app.js\",\n    \"dev\": \"nodemon src/core/app.js\",\n    \"test\": \"npm run test:core && npm run test:modules\",\n    \"test:core\": \"jest src/core\",\n    \"test:modules\": \"git submodule foreach 'npm test'\",\n    \"submodule:init\": \"git submodule update --init --recursive\",\n    \"submodule:update\": \"git submodule update --remote\",\n    \"submodule:status\": \"git submodule status\",\n    \"submodule:summary\": \"git submodule summary\",\n    \"submodule:pull-all\": \"git submodule foreach 'git pull origin main'\",\n    \"submodule:install-deps\": \"git submodule foreach 'npm install'\",\n    \"status-all\": \"git status && git submodule foreach 'git status'\",\n    \"pull-all\": \"git pull && npm run submodule:pull-all\",\n    \"helpers\": \"source scripts/submodule-helpers.sh\"\n  },\n  \"keywords\": [\"modular\", \"submodules\", \"architecture\"],\n  \"author\": \"Development Team\",\n  \"license\": \"MIT\"\n}\nEOF\n\ngit add .\ngit commit -m \"Add submodule management scripts and npm commands\n\n- Create helper scripts for common submodule operations\n- Add npm scripts for submodule management\n- Include documentation and usage examples\n- Support automated submodule workflows\"\n\necho \"\\n=== Submodule Best Practices ===\"\ncat << 'EOF'\n1. **Always use specific commits, not branches**\n   - Submodules point to specific commits, not floating branches\n   - This ensures reproducible builds\n\n2. **Update submodules regularly**\n   - Use `git submodule update --remote` to get latest\n   - Commit submodule updates in main project\n\n3. **Initialize submodules for new clones**\n   - Use `git clone --recursive` for automatic initialization\n   - Or run `git submodule update --init --recursive` after clone\n\n4. **Handle submodule changes carefully**\n   - Changes in submodules must be committed in both submodule and main project\n   - Use `git submodule status` to check for uncommitted changes\n\n5. **Use automation for complex workflows**\n   - Create scripts for common operations\n   - Use npm/yarn scripts for team consistency\n   - Implement CI/CD hooks for submodule updates\n\n6. **Consider alternatives for simpler cases**\n   - Submodules add complexity\n   - Consider npm packages, monorepos, or other solutions\n   - Use submodules when you need:\n     * Independent versioning\n     * Separate access control\n     * Different release cycles\nEOF\n\necho \"\\n=== Repository Structure Summary ===\"\necho \"Main Project Structure:\"\nfind . -type f -name \"*.js\" -o -name \"*.json\" -o -name \"*.md\" | grep -v node_modules | sort\n\necho \"\\n=== Submodule Information ===\"\ngit submodule status\n\necho \"\\n✅ Git submodules demonstration completed!\"\necho \"\\n📝 Key concepts covered:\"\necho \"- Submodule addition and initialization\"\necho \"- Submodule updates and versioning\"\necho \"- Complex workflow management\"\necho \"- Automation scripts and npm integration\"\necho \"- Best practices for team development\"",
      "language": "bash",
      "scenario": "Comprehensive Git submodule management for modular project architecture"
    }
  ],
  "troubleshooting": [
    {
      "problem": "Interactive rebase failed with conflicts",
      "solution": "Resolve conflicts manually, then continue with 'git rebase --continue' or abort with 'git rebase --abort'",
      "commands": ["git status", "git add resolved-file", "git rebase --continue"],
      "details": "Edit conflicted files, remove conflict markers, stage changes, and continue the rebase process"
    },
    {
      "problem": "Lost commits after failed rebase",
      "solution": "Use 'git reflog' to find lost commits and reset to previous state",
      "commands": ["git reflog", "git reset --hard HEAD@{n}"],
      "details": "Reflog keeps track of all HEAD movements; use it to recover from destructive operations"
    },
    {
      "problem": "Submodule shows uncommitted changes but appears clean",
      "solution": "Navigate to submodule directory and check status, may need to commit or reset changes",
      "commands": ["cd submodule-path", "git status", "git reset --hard HEAD"],
      "details": "Submodule working directory state may differ from what main project expects"
    },
    {
      "problem": "Cherry-pick created empty commit",
      "solution": "Use 'git cherry-pick --allow-empty' or skip empty commits during cherry-pick",
      "commands": ["git cherry-pick --skip", "git cherry-pick --allow-empty abc123"],
      "details": "Happens when cherry-picked changes already exist in target branch"
    },
    {
      "problem": "Git bisect stuck on merge commits",
      "solution": "Use 'git bisect skip' for merge commits or 'git bisect start --first-parent'",
      "commands": ["git bisect skip", "git bisect start --first-parent"],
      "details": "Merge commits can complicate bisect; skip them or use first-parent traversal"
    }
  ],
  "tags": ["advanced", "rebase", "cherry-pick", "submodules", "worktree", "bisect", "reflog", "history-manipulation"]
}
