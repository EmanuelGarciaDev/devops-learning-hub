{
  "id": "branching-workflow",
  "toolId": "git",
  "name": "Git Branching & Workflow",
  "description": "Master Git branching strategies, merge workflows, and team collaboration patterns",
  "difficulty": "intermediate",
  "definitions": {
    "beginner": "Git branching allows you to create separate lines of development in your project. Branches let you work on features, fixes, or experiments without affecting the main codebase. You can merge branches back together when work is complete.",
    "advanced": "Git branching is a lightweight mechanism for divergent development paths using commit pointers. Branches are movable references to specific commits, enabling parallel development streams. Merge strategies include fast-forward, three-way merge, and rebase, each with different implications for project history linearity and commit graph topology."
  },
  "commands": [
    {
      "command": "git branch",
      "description": "List, create, or delete branches",
      "example": "git branch feature/new-ui",
      "flags": [
        {
          "flag": "-a",
          "description": "List all branches (local and remote)",
          "example": "-a"
        },
        {
          "flag": "-d",
          "description": "Delete branch (safe delete)",
          "example": "-d feature/old-feature"
        },
        {
          "flag": "-D",
          "description": "Force delete branch",
          "example": "-D feature/abandoned"
        },
        {
          "flag": "-r",
          "description": "List remote branches only",
          "example": "-r"
        }
      ]
    },
    {
      "command": "git checkout",
      "description": "Switch branches or restore files",
      "example": "git checkout main",
      "flags": [
        {
          "flag": "-b",
          "description": "Create and switch to new branch",
          "example": "-b feature/login-system"
        },
        {
          "flag": "-t",
          "description": "Set upstream tracking",
          "example": "-t origin/feature-branch"
        },
        {
          "flag": "--",
          "description": "Restore files to last commit",
          "example": "-- file.txt"
        }
      ]
    },
    {
      "command": "git switch",
      "description": "Switch branches (modern alternative to checkout)",
      "example": "git switch main",
      "flags": [
        {
          "flag": "-c",
          "description": "Create and switch to new branch",
          "example": "-c feature/dashboard"
        },
        {
          "flag": "-",
          "description": "Switch to previous branch",
          "example": "-"
        }
      ]
    },
    {
      "command": "git merge",
      "description": "Merge branches together",
      "example": "git merge feature/user-auth",
      "flags": [
        {
          "flag": "--no-ff",
          "description": "Force merge commit (no fast-forward)",
          "example": "--no-ff feature/payment"
        },
        {
          "flag": "--squash",
          "description": "Squash commits into single commit",
          "example": "--squash feature/refactor"
        },
        {
          "flag": "--abort",
          "description": "Abort merge in progress",
          "example": "--abort"
        }
      ]
    },
    {
      "command": "git rebase",
      "description": "Reapply commits on top of another base",
      "example": "git rebase main",
      "flags": [
        {
          "flag": "-i",
          "description": "Interactive rebase",
          "example": "-i HEAD~3"
        },
        {
          "flag": "--onto",
          "description": "Rebase onto specific commit",
          "example": "--onto main feature~5 feature"
        },
        {
          "flag": "--abort",
          "description": "Abort rebase in progress",
          "example": "--abort"
        },
        {
          "flag": "--continue",
          "description": "Continue rebase after resolving conflicts",
          "example": "--continue"
        }
      ]
    },
    {
      "command": "git cherry-pick",
      "description": "Apply specific commits to current branch",
      "example": "git cherry-pick abc123",
      "flags": [
        {
          "flag": "-n",
          "description": "Don't commit automatically",
          "example": "-n"
        },
        {
          "flag": "-x",
          "description": "Add source commit reference",
          "example": "-x"
        }
      ]
    }
  ],
  "examples": [
    {
      "title": "Git Flow Workflow Implementation",
      "description": "Complete Git Flow workflow with feature, release, and hotfix branches",
      "code": "#!/bin/bash\n# Git Flow Workflow Example\n# Demonstrates professional branching strategy for team development\n\n# Initialize Git Flow repository structure\necho \"=== Initializing Git Flow Repository ===\"\nmkdir git-flow-project\ncd git-flow-project\ngit init\n\n# Set up initial project structure\necho \"Setting up initial project...\"\ncat > README.md << 'EOF'\n# E-Commerce Platform\n\nA modern e-commerce platform built with microservices architecture.\n\n## Branches\n- `main`: Production-ready code\n- `develop`: Integration branch for features\n- `feature/*`: Feature development\n- `release/*`: Release preparation\n- `hotfix/*`: Production fixes\n\n## Version\nCurrent: 1.0.0\nEOF\n\ncat > package.json << 'EOF'\n{\n  \"name\": \"ecommerce-platform\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Modern e-commerce platform\",\n  \"main\": \"src/app.js\",\n  \"scripts\": {\n    \"start\": \"node src/app.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack --mode production\",\n    \"dev\": \"nodemon src/app.js\"\n  },\n  \"keywords\": [\"ecommerce\", \"microservices\", \"nodejs\"],\n  \"author\": \"Development Team\",\n  \"license\": \"MIT\"\n}\nEOF\n\nmkdir -p src/{controllers,models,routes,middleware,utils}\necho \"console.log('E-commerce Platform v1.0.0');\" > src/app.js\n\ncat > .gitignore << 'EOF'\nnode_modules/\n.env\n.env.local\ndist/\nbuild/\n*.log\n.DS_Store\ncoverage/\nEOF\n\n# Initial commit on main branch\ngit add .\ngit commit -m \"Initial commit: Project setup and structure\n\n- Add project documentation\n- Set up package.json with scripts\n- Create basic application structure\n- Add comprehensive .gitignore\"\n\n# Create and switch to develop branch\necho \"\\n=== Setting up Develop Branch ===\"\ngit checkout -b develop\necho \"Created develop branch from main\"\n\n# Feature 1: User Authentication System\necho \"\\n=== Feature Development: User Authentication ===\"\ngit checkout -b feature/user-authentication develop\n\n# Implement authentication system\nmkdir -p src/auth\ncat > src/auth/authController.js << 'EOF'\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User');\n\nclass AuthController {\n    async register(req, res) {\n        try {\n            const { username, email, password } = req.body;\n            \n            // Check if user exists\n            const existingUser = await User.findByEmail(email);\n            if (existingUser) {\n                return res.status(400).json({ error: 'User already exists' });\n            }\n            \n            // Hash password\n            const saltRounds = 12;\n            const hashedPassword = await bcrypt.hash(password, saltRounds);\n            \n            // Create user\n            const user = await User.create({\n                username,\n                email,\n                password: hashedPassword\n            });\n            \n            // Generate JWT\n            const token = jwt.sign(\n                { userId: user.id, email: user.email },\n                process.env.JWT_SECRET,\n                { expiresIn: '24h' }\n            );\n            \n            res.status(201).json({\n                message: 'User registered successfully',\n                token,\n                user: { id: user.id, username, email }\n            });\n        } catch (error) {\n            res.status(500).json({ error: 'Registration failed' });\n        }\n    }\n    \n    async login(req, res) {\n        try {\n            const { email, password } = req.body;\n            \n            // Find user\n            const user = await User.findByEmail(email);\n            if (!user) {\n                return res.status(401).json({ error: 'Invalid credentials' });\n            }\n            \n            // Verify password\n            const isValidPassword = await bcrypt.compare(password, user.password);\n            if (!isValidPassword) {\n                return res.status(401).json({ error: 'Invalid credentials' });\n            }\n            \n            // Generate JWT\n            const token = jwt.sign(\n                { userId: user.id, email: user.email },\n                process.env.JWT_SECRET,\n                { expiresIn: '24h' }\n            );\n            \n            res.json({\n                message: 'Login successful',\n                token,\n                user: { id: user.id, username: user.username, email }\n            });\n        } catch (error) {\n            res.status(500).json({ error: 'Login failed' });\n        }\n    }\n    \n    async logout(req, res) {\n        // In a real app, you'd blacklist the token\n        res.json({ message: 'Logout successful' });\n    }\n}\n\nmodule.exports = new AuthController();\nEOF\n\ncat > src/models/User.js << 'EOF'\nclass User {\n    constructor(data) {\n        this.id = data.id;\n        this.username = data.username;\n        this.email = data.email;\n        this.password = data.password;\n        this.createdAt = data.createdAt || new Date();\n        this.updatedAt = data.updatedAt || new Date();\n    }\n    \n    static async findByEmail(email) {\n        // In real app, this would query database\n        // For demo, return null (user not found)\n        return null;\n    }\n    \n    static async create(userData) {\n        // In real app, this would save to database\n        return new User({\n            id: Math.random().toString(36).substr(2, 9),\n            ...userData\n        });\n    }\n    \n    static async findById(id) {\n        // Database query implementation\n        return null;\n    }\n}\n\nmodule.exports = User;\nEOF\n\ncat > src/middleware/auth.js << 'EOF'\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User');\n\nconst authMiddleware = async (req, res, next) => {\n    try {\n        const token = req.header('Authorization')?.replace('Bearer ', '');\n        \n        if (!token) {\n            return res.status(401).json({ error: 'Access denied. No token provided.' });\n        }\n        \n        const decoded = jwt.verify(token, process.env.JWT_SECRET);\n        const user = await User.findById(decoded.userId);\n        \n        if (!user) {\n            return res.status(401).json({ error: 'Invalid token.' });\n        }\n        \n        req.user = user;\n        next();\n    } catch (error) {\n        res.status(401).json({ error: 'Invalid token.' });\n    }\n};\n\nmodule.exports = authMiddleware;\nEOF\n\n# Update package.json with auth dependencies\ncat > package.json << 'EOF'\n{\n  \"name\": \"ecommerce-platform\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Modern e-commerce platform with authentication\",\n  \"main\": \"src/app.js\",\n  \"scripts\": {\n    \"start\": \"node src/app.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack --mode production\",\n    \"dev\": \"nodemon src/app.js\"\n  },\n  \"dependencies\": {\n    \"bcrypt\": \"^5.1.0\",\n    \"jsonwebtoken\": \"^9.0.0\",\n    \"express\": \"^4.18.0\",\n    \"dotenv\": \"^16.0.0\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.0.0\",\n    \"nodemon\": \"^2.0.0\"\n  },\n  \"keywords\": [\"ecommerce\", \"authentication\", \"jwt\", \"nodejs\"],\n  \"author\": \"Development Team\",\n  \"license\": \"MIT\"\n}\nEOF\n\n# Commit authentication feature\ngit add .\ngit commit -m \"Implement user authentication system\n\n- Add AuthController with register/login/logout methods\n- Implement User model with database operations\n- Add JWT-based authentication middleware\n- Update package.json with auth dependencies\n- Add comprehensive error handling and validation\"\n\n# Create tests for authentication\nmkdir -p tests/auth\ncat > tests/auth/authController.test.js << 'EOF'\nconst request = require('supertest');\nconst app = require('../../src/app');\n\ndescribe('Authentication Controller', () => {\n    describe('POST /api/auth/register', () => {\n        it('should register a new user', async () => {\n            const userData = {\n                username: 'testuser',\n                email: 'test@example.com',\n                password: 'password123'\n            };\n            \n            const response = await request(app)\n                .post('/api/auth/register')\n                .send(userData)\n                .expect(201);\n                \n            expect(response.body).toHaveProperty('token');\n            expect(response.body.user.email).toBe(userData.email);\n        });\n        \n        it('should not register user with invalid email', async () => {\n            const userData = {\n                username: 'testuser',\n                email: 'invalid-email',\n                password: 'password123'\n            };\n            \n            await request(app)\n                .post('/api/auth/register')\n                .send(userData)\n                .expect(400);\n        });\n    });\n    \n    describe('POST /api/auth/login', () => {\n        it('should login with valid credentials', async () => {\n            // Implementation for login test\n        });\n        \n        it('should reject invalid credentials', async () => {\n            // Implementation for invalid login test\n        });\n    });\n});\nEOF\n\ngit add tests/\ngit commit -m \"Add comprehensive tests for authentication system\n\n- Implement unit tests for AuthController\n- Add test cases for registration and login\n- Include validation and error handling tests\"\n\n# Switch to develop and merge feature\necho \"\\n=== Merging Feature to Develop ===\"\ngit checkout develop\ngit merge --no-ff feature/user-authentication\necho \"Merged feature/user-authentication into develop\"\n\n# Clean up feature branch\ngit branch -d feature/user-authentication\n\n# Feature 2: Product Management\necho \"\\n=== Feature Development: Product Management ===\"\ngit checkout -b feature/product-management develop\n\n# Implement product management\ncat > src/controllers/productController.js << 'EOF'\nconst Product = require('../models/Product');\n\nclass ProductController {\n    async getAllProducts(req, res) {\n        try {\n            const { page = 1, limit = 10, category, search } = req.query;\n            const filters = {};\n            \n            if (category) filters.category = category;\n            if (search) filters.search = search;\n            \n            const products = await Product.findAll({\n                ...filters,\n                page: parseInt(page),\n                limit: parseInt(limit)\n            });\n            \n            res.json({\n                products: products.data,\n                pagination: {\n                    page: products.page,\n                    limit: products.limit,\n                    total: products.total,\n                    totalPages: Math.ceil(products.total / products.limit)\n                }\n            });\n        } catch (error) {\n            res.status(500).json({ error: 'Failed to fetch products' });\n        }\n    }\n    \n    async getProductById(req, res) {\n        try {\n            const { id } = req.params;\n            const product = await Product.findById(id);\n            \n            if (!product) {\n                return res.status(404).json({ error: 'Product not found' });\n            }\n            \n            res.json(product);\n        } catch (error) {\n            res.status(500).json({ error: 'Failed to fetch product' });\n        }\n    }\n    \n    async createProduct(req, res) {\n        try {\n            const productData = req.body;\n            \n            // Validate required fields\n            const requiredFields = ['name', 'price', 'category', 'description'];\n            for (const field of requiredFields) {\n                if (!productData[field]) {\n                    return res.status(400).json({ error: `${field} is required` });\n                }\n            }\n            \n            const product = await Product.create(productData);\n            res.status(201).json(product);\n        } catch (error) {\n            res.status(500).json({ error: 'Failed to create product' });\n        }\n    }\n    \n    async updateProduct(req, res) {\n        try {\n            const { id } = req.params;\n            const updateData = req.body;\n            \n            const product = await Product.findByIdAndUpdate(id, updateData);\n            \n            if (!product) {\n                return res.status(404).json({ error: 'Product not found' });\n            }\n            \n            res.json(product);\n        } catch (error) {\n            res.status(500).json({ error: 'Failed to update product' });\n        }\n    }\n    \n    async deleteProduct(req, res) {\n        try {\n            const { id } = req.params;\n            const deleted = await Product.findByIdAndDelete(id);\n            \n            if (!deleted) {\n                return res.status(404).json({ error: 'Product not found' });\n            }\n            \n            res.json({ message: 'Product deleted successfully' });\n        } catch (error) {\n            res.status(500).json({ error: 'Failed to delete product' });\n        }\n    }\n}\n\nmodule.exports = new ProductController();\nEOF\n\ncat > src/models/Product.js << 'EOF'\nclass Product {\n    constructor(data) {\n        this.id = data.id;\n        this.name = data.name;\n        this.description = data.description;\n        this.price = data.price;\n        this.category = data.category;\n        this.images = data.images || [];\n        this.inventory = data.inventory || 0;\n        this.tags = data.tags || [];\n        this.createdAt = data.createdAt || new Date();\n        this.updatedAt = data.updatedAt || new Date();\n    }\n    \n    static async findAll(options = {}) {\n        // Database query implementation\n        return {\n            data: [],\n            page: options.page || 1,\n            limit: options.limit || 10,\n            total: 0\n        };\n    }\n    \n    static async findById(id) {\n        // Database query implementation\n        return null;\n    }\n    \n    static async create(productData) {\n        return new Product({\n            id: Math.random().toString(36).substr(2, 9),\n            ...productData\n        });\n    }\n    \n    static async findByIdAndUpdate(id, updateData) {\n        // Database update implementation\n        return null;\n    }\n    \n    static async findByIdAndDelete(id) {\n        // Database delete implementation\n        return null;\n    }\n}\n\nmodule.exports = Product;\nEOF\n\n# Add routes\ncat > src/routes/productRoutes.js << 'EOF'\nconst express = require('express');\nconst productController = require('../controllers/productController');\nconst authMiddleware = require('../middleware/auth');\n\nconst router = express.Router();\n\n// Public routes\nrouter.get('/', productController.getAllProducts);\nrouter.get('/:id', productController.getProductById);\n\n// Protected routes (require authentication)\nrouter.post('/', authMiddleware, productController.createProduct);\nrouter.put('/:id', authMiddleware, productController.updateProduct);\nrouter.delete('/:id', authMiddleware, productController.deleteProduct);\n\nmodule.exports = router;\nEOF\n\ngit add .\ngit commit -m \"Implement product management system\n\n- Add ProductController with CRUD operations\n- Implement Product model with pagination support\n- Add product routes with authentication middleware\n- Include comprehensive validation and error handling\"\n\n# Merge product management to develop\ngit checkout develop\ngit merge --no-ff feature/product-management\ngit branch -d feature/product-management\n\n# Create release branch\necho \"\\n=== Creating Release Branch ===\"\ngit checkout -b release/1.1.0 develop\n\n# Prepare release (update version, documentation)\ncat > package.json << 'EOF'\n{\n  \"name\": \"ecommerce-platform\",\n  \"version\": \"1.1.0\",\n  \"description\": \"E-commerce platform with authentication and product management\",\n  \"main\": \"src/app.js\",\n  \"scripts\": {\n    \"start\": \"node src/app.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack --mode production\",\n    \"dev\": \"nodemon src/app.js\"\n  },\n  \"dependencies\": {\n    \"bcrypt\": \"^5.1.0\",\n    \"jsonwebtoken\": \"^9.0.0\",\n    \"express\": \"^4.18.0\",\n    \"dotenv\": \"^16.0.0\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.0.0\",\n    \"nodemon\": \"^2.0.0\",\n    \"supertest\": \"^6.3.0\"\n  },\n  \"keywords\": [\"ecommerce\", \"authentication\", \"product-management\", \"nodejs\"],\n  \"author\": \"Development Team\",\n  \"license\": \"MIT\"\n}\nEOF\n\ncat > CHANGELOG.md << 'EOF'\n# Changelog\n\n## [1.1.0] - 2024-01-15\n\n### Added\n- User authentication system with JWT\n- Product management with CRUD operations\n- Authentication middleware for protected routes\n- Comprehensive test suite\n- Input validation and error handling\n\n### Security\n- Password hashing with bcrypt\n- JWT token-based authentication\n- Protected routes for admin operations\n\n## [1.0.0] - 2024-01-01\n\n### Added\n- Initial project structure\n- Basic application setup\n- Development environment configuration\nEOF\n\ngit add .\ngit commit -m \"Prepare release 1.1.0\n\n- Update version to 1.1.0\n- Add comprehensive CHANGELOG\n- Update package.json dependencies\n- Finalize release documentation\"\n\n# Release to main\necho \"\\n=== Merging Release to Main ===\"\ngit checkout main\ngit merge --no-ff release/1.1.0\ngit tag -a v1.1.0 -m \"Release version 1.1.0\n\nFeatures:\n- User authentication system\n- Product management\n- JWT-based security\n- Comprehensive testing\"\n\n# Merge back to develop\ngit checkout develop\ngit merge --no-ff release/1.1.0\ngit branch -d release/1.1.0\n\n# Simulate production hotfix\necho \"\\n=== Hotfix Workflow ===\"\ngit checkout main\ngit checkout -b hotfix/security-patch\n\n# Fix security issue\ncat > src/middleware/rateLimiter.js << 'EOF'\nconst rateLimit = require('express-rate-limit');\n\n// Rate limiting middleware\nconst createRateLimiter = (windowMs, max, message) => {\n    return rateLimit({\n        windowMs,\n        max,\n        message: { error: message },\n        standardHeaders: true,\n        legacyHeaders: false,\n        handler: (req, res) => {\n            res.status(429).json({\n                error: message,\n                retryAfter: Math.round(windowMs / 1000)\n            });\n        }\n    });\n};\n\n// Different rate limits for different endpoints\nconst authLimiter = createRateLimiter(\n    15 * 60 * 1000, // 15 minutes\n    5, // limit each IP to 5 requests per windowMs\n    'Too many authentication attempts, please try again later'\n);\n\nconst generalLimiter = createRateLimiter(\n    15 * 60 * 1000, // 15 minutes\n    100, // limit each IP to 100 requests per windowMs\n    'Too many requests, please try again later'\n);\n\nmodule.exports = {\n    authLimiter,\n    generalLimiter\n};\nEOF\n\n# Update package.json version\nsed -i 's/\"version\": \"1.1.0\"/\"version\": \"1.1.1\"/' package.json\n\ngit add .\ngit commit -m \"Security hotfix: Add rate limiting\n\n- Implement rate limiting middleware\n- Add different limits for auth and general endpoints\n- Prevent brute force attacks\n- Update to version 1.1.1\"\n\n# Merge hotfix to main and develop\ngit checkout main\ngit merge --no-ff hotfix/security-patch\ngit tag -a v1.1.1 -m \"Hotfix version 1.1.1: Security improvements\"\n\ngit checkout develop\ngit merge --no-ff hotfix/security-patch\ngit branch -d hotfix/security-patch\n\n# Display final repository state\necho \"\\n=== Repository Summary ===\"\necho \"Current branch: $(git branch --show-current)\"\necho \"\\nBranch structure:\"\ngit branch -a\necho \"\\nRecent commits:\"\ngit log --oneline --graph --all -10\necho \"\\nTags:\"\ngit tag -l\necho \"\\n✅ Git Flow workflow completed successfully!\"\n\n# Advanced branching examples\necho \"\\n=== Advanced Branching Techniques ===\"\n\n# Feature branch with interactive rebase\ngit checkout -b feature/advanced-search develop\n\n# Create multiple small commits\necho \"// Basic search functionality\" > src/utils/search.js\ngit add .\ngit commit -m \"Add basic search structure\"\n\necho \"// Add text search\" >> src/utils/search.js\ngit add .\ngit commit -m \"Implement text search\"\n\necho \"// Add filters\" >> src/utils/search.js\ngit add .\ngit commit -m \"Add search filters\"\n\necho \"// Add sorting\" >> src/utils/search.js\ngit add .\ngit commit -m \"Add search sorting\"\n\necho \"// Optimize performance\" >> src/utils/search.js\ngit add .\ngit commit -m \"Optimize search performance\"\n\n# Interactive rebase to clean up commits\necho \"\\nDemonstrating interactive rebase...\"\necho \"# This would open editor for interactive rebase:\"\necho \"# git rebase -i HEAD~5\"\necho \"# Options: pick, reword, edit, squash, fixup, drop\"\n\n# Cherry-pick example\ngit checkout develop\necho \"\\nCherry-picking specific commit...\"\n# git cherry-pick <commit-hash>\n\necho \"\\n=== Workflow Best Practices ===\"\necho \"1. Always create feature branches from develop\"\necho \"2. Use descriptive branch names (feature/user-auth, hotfix/security)\"\necho \"3. Keep commits atomic and well-described\"\necho \"4. Use --no-ff for merge commits to preserve branch history\"\necho \"5. Tag releases for easy rollback\"\necho \"6. Clean up merged branches\"\necho \"7. Rebase feature branches before merging to maintain clean history\"\n\necho \"\\n✅ Advanced Git workflow demonstration completed!\"",
      "language": "bash",
      "scenario": "Complete Git Flow implementation with feature development, releases, and hotfixes"
    },
    {
      "title": "Conflict Resolution and Merge Strategies",
      "description": "Advanced conflict resolution techniques and merge strategy selection",
      "code": "#!/bin/bash\n# Git Conflict Resolution and Merge Strategies\n# Demonstrates various merge scenarios and resolution techniques\n\necho \"=== Git Conflict Resolution Demo ===\"\nmkdir conflict-resolution-demo\ncd conflict-resolution-demo\ngit init\n\n# Initial setup with shared file\ncat > shared-config.json << 'EOF'\n{\n  \"app\": {\n    \"name\": \"My Application\",\n    \"version\": \"1.0.0\",\n    \"environment\": \"development\",\n    \"database\": {\n      \"host\": \"localhost\",\n      \"port\": 5432,\n      \"name\": \"myapp_dev\"\n    },\n    \"api\": {\n      \"baseUrl\": \"http://localhost:3000\",\n      \"timeout\": 5000\n    }\n  }\n}\nEOF\n\ncat > README.md << 'EOF'\n# Application Configuration\n\nThis project demonstrates conflict resolution in Git.\n\n## Features\n- Configuration management\n- Environment settings\n- Database configuration\nEOF\n\ngit add .\ngit commit -m \"Initial commit: Add shared configuration\"\n\n# Create two conflicting branches\necho \"\\n=== Creating Conflicting Branches ===\"\n\n# Branch 1: Feature A (Database updates)\ngit checkout -b feature/database-config\n\n# Modify database configuration\ncat > shared-config.json << 'EOF'\n{\n  \"app\": {\n    \"name\": \"My Application\",\n    \"version\": \"1.1.0\",\n    \"environment\": \"development\",\n    \"database\": {\n      \"host\": \"db.example.com\",\n      \"port\": 5432,\n      \"name\": \"myapp_production\",\n      \"ssl\": true,\n      \"pool\": {\n        \"min\": 2,\n        \"max\": 10\n      }\n    },\n    \"api\": {\n      \"baseUrl\": \"http://localhost:3000\",\n      \"timeout\": 5000\n    },\n    \"cache\": {\n      \"enabled\": true,\n      \"ttl\": 3600\n    }\n  }\n}\nEOF\n\necho \"\\n## Database Features\" >> README.md\necho \"- Production database configuration\" >> README.md\necho \"- Connection pooling\" >> README.md\necho \"- SSL support\" >> README.md\n\ngit add .\ngit commit -m \"Add production database configuration\n\n- Update database host to production server\n- Add SSL configuration\n- Implement connection pooling\n- Add caching configuration\"\n\n# Branch 2: Feature B (API updates)\ngit checkout main\ngit checkout -b feature/api-config\n\n# Modify API configuration (conflicting changes)\ncat > shared-config.json << 'EOF'\n{\n  \"app\": {\n    \"name\": \"My Application\",\n    \"version\": \"1.2.0\",\n    \"environment\": \"development\",\n    \"database\": {\n      \"host\": \"localhost\",\n      \"port\": 5432,\n      \"name\": \"myapp_dev\"\n    },\n    \"api\": {\n      \"baseUrl\": \"https://api.example.com\",\n      \"timeout\": 10000,\n      \"retries\": 3,\n      \"authentication\": {\n        \"type\": \"bearer\",\n        \"endpoint\": \"/auth/token\"\n      }\n    },\n    \"logging\": {\n      \"level\": \"info\",\n      \"file\": \"app.log\"\n    }\n  }\n}\nEOF\n\necho \"\\n## API Features\" >> README.md\necho \"- Production API endpoints\" >> README.md\necho \"- Authentication configuration\" >> README.md\necho \"- Retry mechanisms\" >> README.md\necho \"- Comprehensive logging\" >> README.md\n\ngit add .\ngit commit -m \"Add production API configuration\n\n- Update API endpoints to production\n- Add authentication configuration\n- Implement retry mechanisms\n- Add logging configuration\"\n\n# Attempt merge to create conflict\necho \"\\n=== Creating Merge Conflict ===\"\ngit checkout main\necho \"Attempting to merge feature/database-config...\"\ngit merge feature/database-config  # This should succeed\n\necho \"\\nAttempting to merge feature/api-config...\"\ngit merge feature/api-config || echo \"Merge conflict detected!\"\n\n# Show conflict status\necho \"\\n=== Analyzing Conflict ===\"\necho \"Git status:\"\ngit status\n\necho \"\\nConflicted files:\"\ngit diff --name-only --diff-filter=U\n\necho \"\\nDetailed conflict view:\"\ngit diff shared-config.json\n\n# Manual conflict resolution\necho \"\\n=== Manual Conflict Resolution ===\"\necho \"Resolving conflicts manually...\"\n\n# Create resolved version that combines both features\ncat > shared-config.json << 'EOF'\n{\n  \"app\": {\n    \"name\": \"My Application\",\n    \"version\": \"1.2.0\",\n    \"environment\": \"development\",\n    \"database\": {\n      \"host\": \"db.example.com\",\n      \"port\": 5432,\n      \"name\": \"myapp_production\",\n      \"ssl\": true,\n      \"pool\": {\n        \"min\": 2,\n        \"max\": 10\n      }\n    },\n    \"api\": {\n      \"baseUrl\": \"https://api.example.com\",\n      \"timeout\": 10000,\n      \"retries\": 3,\n      \"authentication\": {\n        \"type\": \"bearer\",\n        \"endpoint\": \"/auth/token\"\n      }\n    },\n    \"cache\": {\n      \"enabled\": true,\n      \"ttl\": 3600\n    },\n    \"logging\": {\n      \"level\": \"info\",\n      \"file\": \"app.log\"\n    }\n  }\n}\nEOF\n\n# Also resolve README conflict\ncat > README.md << 'EOF'\n# Application Configuration\n\nThis project demonstrates conflict resolution in Git.\n\n## Features\n- Configuration management\n- Environment settings\n- Database configuration\n\n## Database Features\n- Production database configuration\n- Connection pooling\n- SSL support\n\n## API Features\n- Production API endpoints\n- Authentication configuration\n- Retry mechanisms\n- Comprehensive logging\nEOF\n\n# Mark conflicts as resolved and complete merge\ngit add .\ngit commit -m \"Merge feature/api-config: Resolve configuration conflicts\n\nResolved conflicts by combining:\n- Database features: production host, SSL, connection pooling\n- API features: production endpoints, authentication, retries\n- Combined logging and caching configurations\n- Updated version to 1.2.0 to reflect both feature sets\"\n\necho \"\\n=== Advanced Merge Strategies ===\"\n\n# Demonstrate different merge strategies\ngit checkout -b demo/merge-strategies\n\n# Strategy 1: Ours strategy (keep our version)\necho \"\\n1. Ours Strategy Demo\"\ngit checkout -b conflict-demo-ours main~2\necho \"Our version content\" > strategy-demo.txt\ngit add .\ngit commit -m \"Add our version\"\n\ngit checkout -b conflict-demo-theirs main~2\necho \"Their version content\" > strategy-demo.txt\ngit add .\ngit commit -m \"Add their version\"\n\ngit checkout conflict-demo-ours\necho \"Merging with 'ours' strategy...\"\ngit merge -X ours conflict-demo-theirs\necho \"Result: $(cat strategy-demo.txt)\"\n\n# Strategy 2: Theirs strategy (take their version)\ngit checkout conflict-demo-theirs\necho \"\\n2. Theirs Strategy Demo\"\ngit reset --hard HEAD~1\necho \"Their version content\" > strategy-demo.txt\ngit add .\ngit commit -m \"Add their version again\"\n\ngit merge -X theirs conflict-demo-ours\necho \"Result: $(cat strategy-demo.txt)\"\n\n# Strategy 3: Patience diff algorithm\necho \"\\n3. Patience Diff Algorithm\"\ngit checkout main\ngit checkout -b demo/patience-diff\n\n# Create file with different sorting\ncat > data-file.txt << 'EOF'\napple\nbanana\ncherry\ndate\nfig\ngrape\nEOF\n\ngit add .\ngit commit -m \"Add initial sorted data\"\n\n# Branch 1: Add items at beginning and end\ngit checkout -b add-beginning-end\nsed -i '1i\\antelope' data-file.txt\necho \"kiwi\" >> data-file.txt\ngit add .\ngit commit -m \"Add items at beginning and end\"\n\n# Branch 2: Add items in middle\ngit checkout demo/patience-diff\ngit checkout -b add-middle\nsed -i '3a\\durian' data-file.txt\ngit add .\ngit commit -m \"Add item in middle\"\n\n# Merge with patience algorithm\ngit checkout add-beginning-end\necho \"Merging with patience diff algorithm...\"\ngit merge -X patience add-middle\necho \"Result:\"\ncat data-file.txt\n\n# Cleanup and return to main\ngit checkout main\ngit branch -D conflict-demo-ours conflict-demo-theirs demo/merge-strategies demo/patience-diff add-beginning-end add-middle\n\necho \"\\n=== Merge Tools Configuration ===\"\n\n# Configure merge tools\necho \"Setting up merge tools...\"\n\n# VS Code as merge tool\ngit config merge.tool vscode\ngit config mergetool.vscode.cmd 'code --wait $MERGED'\ngit config mergetool.keepBackup false\n\n# Alternative: Vim as merge tool\ngit config merge.tool vimdiff\ngit config mergetool.vimdiff.cmd 'vim -d $LOCAL $BASE $REMOTE $MERGED -c \"wincmd w\" -c \"wincmd J\"'\n\necho \"\\nConfigured merge tools:\"\ngit config --get merge.tool\ngit config --get mergetool.vscode.cmd\n\necho \"\\n=== Conflict Prevention Strategies ===\"\n\ncat > .gitattributes << 'EOF'\n# Define merge strategies for specific files\n*.json merge=ours\n*.config merge=union\ndatabase.yml merge=ours\n\n# Use custom merge driver for specific files\nCHANGELOG.md merge=changelog-merge\n\n# Binary files\n*.exe binary\n*.png binary\n*.jpg binary\nEOF\n\ngit add .gitattributes\ngit commit -m \"Add .gitattributes for merge strategies\n\n- Set JSON files to use 'ours' strategy\n- Set config files to use 'union' strategy\n- Define binary file handling\"\n\necho \"\\n=== Rebase vs Merge Comparison ===\"\n\n# Create example for rebase vs merge\ngit checkout -b demo/rebase-example\necho \"Feature work 1\" > feature-work.txt\ngit add .\ngit commit -m \"Feature work 1\"\n\necho \"Feature work 2\" >> feature-work.txt\ngit add .\ngit commit -m \"Feature work 2\"\n\n# Simulate main branch progress\ngit checkout main\necho \"Main progress\" > main-work.txt\ngit add .\ngit commit -m \"Main branch progress\"\n\n# Show difference between merge and rebase\necho \"\\nBefore rebase - commit history:\"\ngit log --oneline --graph --all\n\n# Rebase feature branch\ngit checkout demo/rebase-example\necho \"\\nRebasing feature branch onto main...\"\ngit rebase main\n\necho \"\\nAfter rebase - linear history:\"\ngit log --oneline --graph --all\n\n# Compare with merge approach\ngit checkout main\ngit checkout -b demo/merge-example demo/rebase-example~2\necho \"Feature work 1 (merge demo)\" > feature-work-merge.txt\ngit add .\ngit commit -m \"Feature work 1 (merge demo)\"\n\necho \"Feature work 2 (merge demo)\" >> feature-work-merge.txt\ngit add .\ngit commit -m \"Feature work 2 (merge demo)\"\n\ngit checkout main\necho \"\\nMerging with --no-ff to preserve branch history:\"\ngit merge --no-ff demo/merge-example\n\necho \"\\nAfter merge - preserves branch structure:\"\ngit log --oneline --graph --all\n\n# Cleanup\ngit branch -D demo/rebase-example demo/merge-example feature/database-config feature/api-config\n\necho \"\\n=== Best Practices Summary ===\"\necho \"1. Use 'git status' and 'git diff' to understand conflicts\"\necho \"2. Configure merge tools for better conflict resolution\"\necho \"3. Use .gitattributes to define merge strategies per file type\"\necho \"4. Choose rebase for linear history, merge for preserving context\"\necho \"5. Always test after resolving conflicts\"\necho \"6. Use descriptive commit messages for conflict resolutions\"\necho \"7. Consider using 'git rerere' for recurring conflicts\"\n\necho \"\\n✅ Conflict resolution and merge strategies demo completed!\"",
      "language": "bash",
      "scenario": "Comprehensive conflict resolution techniques and merge strategy demonstration"
    }
  ],
  "troubleshooting": [
    {
      "problem": "Cannot switch branches due to uncommitted changes",
      "solution": "Stash changes with 'git stash' before switching, or commit them first",
      "commands": ["git stash", "git checkout branch-name", "git stash pop"],
      "details": "Git prevents losing work by blocking branch switches with uncommitted changes. Use stash to temporarily save work."
    },
    {
      "problem": "Merge conflicts during branch merge",
      "solution": "Resolve conflicts manually in files, then add and commit the resolution",
      "commands": ["git status", "git diff", "git add resolved-file", "git commit"],
      "details": "Edit files to resolve <<<<<<< ======= >>>>>>> markers, then stage and commit the resolution"
    },
    {
      "problem": "Accidentally merged wrong branch",
      "solution": "Use 'git reset --hard HEAD~1' to undo merge if not pushed, or 'git revert' if pushed",
      "commands": ["git reset --hard HEAD~1", "git revert -m 1 HEAD"],
      "details": "Reset for local-only changes, revert for shared repository history"
    },
    {
      "problem": "Branch diverged too much from main",
      "solution": "Use interactive rebase to clean up commits before merging",
      "commands": ["git rebase -i main", "git rebase --continue"],
      "details": "Interactive rebase allows squashing, reordering, and editing commits for cleaner history"
    },
    {
      "problem": "Lost commits after rebasing",
      "solution": "Use 'git reflog' to find lost commits and 'git reset' to recover",
      "commands": ["git reflog", "git reset --hard HEAD@{n}"],
      "details": "Reflog shows all HEAD movements; use it to recover from destructive operations"
    }
  ],
  "tags": ["branching", "merge", "workflow", "git-flow", "collaboration", "conflict-resolution"]
}
