{
  "id": "roles-collections",
  "toolId": "ansible",
  "name": "Roles & Collections",
  "description": "Master Ansible roles and collections for reusable, modular automation with community packages and custom development",
  "difficulty": "advanced",
  "definitions": {
    "beginner": "Ansible roles are reusable units of automation that group tasks, variables, files, and templates. Collections are distribution packages that bundle roles, modules, and plugins together for sharing and installation.",
    "advanced": "Ansible roles provide structured automation frameworks with defined directory layouts, dependency management, and variable scoping. Collections extend this with namespaced distribution packages containing roles, modules, plugins, and documentation, enabling ecosystem-wide sharing through Ansible Galaxy and private repositories."
  },
  "commands": [
    {
      "command": "ansible-galaxy role init",
      "description": "Create a new role structure",
      "example": "ansible-galaxy role init my_role",
      "flags": [
        {
          "flag": "--init-path",
          "description": "Specify path for role creation",
          "example": "--init-path ./roles"
        },
        {
          "flag": "--force",
          "description": "Force overwrite existing role",
          "example": "--force"
        }
      ]
    },
    {
      "command": "ansible-galaxy role install",
      "description": "Install roles from Galaxy or Git",
      "example": "ansible-galaxy role install geerlingguy.nginx",
      "flags": [
        {
          "flag": "-r",
          "description": "Install from requirements file",
          "example": "-r requirements.yml"
        },
        {
          "flag": "-p",
          "description": "Specify installation path",
          "example": "-p ./roles"
        },
        {
          "flag": "--force",
          "description": "Force reinstallation",
          "example": "--force"
        }
      ]
    },
    {
      "command": "ansible-galaxy collection install",
      "description": "Install collections",
      "example": "ansible-galaxy collection install community.general",
      "flags": [
        {
          "flag": "-r",
          "description": "Install from requirements file",
          "example": "-r requirements.yml"
        },
        {
          "flag": "--upgrade",
          "description": "Upgrade to latest version",
          "example": "--upgrade"
        }
      ]
    },
    {
      "command": "ansible-galaxy collection build",
      "description": "Build collection tarball",
      "example": "ansible-galaxy collection build"
    },
    {
      "command": "ansible-galaxy collection publish",
      "description": "Publish collection to Galaxy",
      "example": "ansible-galaxy collection publish my-collection-1.0.0.tar.gz"
    }
  ],
  "examples": [
    {
      "title": "Complete Web Application Role Structure",
      "description": "Comprehensive role for deploying and managing web applications with monitoring and security",
      "code": "# roles/webapp/meta/main.yml\n---\ngalaxy_info:\n  role_name: webapp\n  author: DevOps Team\n  description: Complete web application deployment and management\n  company: Example Corp\n  license: MIT\n  min_ansible_version: 2.9\n  platforms:\n    - name: Ubuntu\n      versions:\n        - focal\n        - jammy\n    - name: CentOS\n      versions:\n        - 7\n        - 8\n  galaxy_tags:\n    - web\n    - application\n    - deployment\n    - monitoring\n\ndependencies:\n  - role: geerlingguy.nginx\n    vars:\n      nginx_remove_default_vhost: true\n  - role: geerlingguy.nodejs\n    vars:\n      nodejs_version: \"16.x\"\n  - role: geerlingguy.mysql\n    when: webapp_database_type == \"mysql\"\n  - role: community.postgresql\n    when: webapp_database_type == \"postgresql\"\n\n---\n# roles/webapp/defaults/main.yml\n---\n# Application configuration\nwebapp_name: myapp\nwebapp_version: latest\nwebapp_user: \"{{ webapp_name }}\"\nwebapp_group: \"{{ webapp_name }}\"\nwebapp_home: \"/opt/{{ webapp_name }}\"\nwebapp_port: 3000\nwebapp_env: production\n\n# Repository settings\nwebapp_repo_url: \"https://github.com/example/{{ webapp_name }}.git\"\nwebapp_repo_version: \"{{ webapp_version }}\"\nwebapp_repo_key_file: \"\"\n\n# Database configuration\nwebapp_database_type: mysql  # mysql, postgresql, none\nwebapp_database_host: localhost\nwebapp_database_port: 3306\nwebapp_database_name: \"{{ webapp_name }}_{{ webapp_env }}\"\nwebapp_database_user: \"{{ webapp_name }}_user\"\nwebapp_database_password: \"{{ vault_webapp_database_password | default('changeme') }}\"\n\n# SSL/TLS configuration\nwebapp_ssl_enabled: true\nwebapp_ssl_cert_path: \"/etc/ssl/certs/{{ webapp_name }}.crt\"\nwebapp_ssl_key_path: \"/etc/ssl/private/{{ webapp_name }}.key\"\nwebapp_ssl_protocols: \"TLSv1.2 TLSv1.3\"\n\n# Nginx configuration\nwebapp_nginx_client_max_body_size: \"10m\"\nwebapp_nginx_worker_connections: 1024\nwebapp_nginx_keepalive_timeout: 65\n\n# PM2 configuration\nwebapp_pm2_instances: \"{{ ansible_processor_vcpus }}\"\nwebapp_pm2_max_memory_restart: \"500M\"\nwebapp_pm2_max_restarts: 10\nwebapp_pm2_min_uptime: \"10s\"\n\n# Monitoring\nwebapp_monitoring_enabled: true\nwebapp_metrics_port: 9090\nwebapp_health_check_path: \"/health\"\n\n# Backup configuration\nwebapp_backup_enabled: true\nwebapp_backup_schedule: \"0 2 * * *\"\nwebapp_backup_retention_days: 7\nwebapp_backup_s3_bucket: \"{{ webapp_name }}-backups\"\n\n# Logging\nwebapp_log_level: info\nwebapp_log_max_files: 5\nwebapp_log_max_size: \"10m\"\nwebapp_access_log_enabled: true\n\n# Security\nwebapp_firewall_enabled: true\nwebapp_fail2ban_enabled: true\nwebapp_security_headers_enabled: true\n\n# Performance\nwebapp_cache_enabled: true\nwebapp_gzip_enabled: true\nwebapp_static_cache_duration: \"1d\"\n\n---\n# roles/webapp/vars/main.yml\n---\n# Internal variables\n_webapp_service_name: \"{{ webapp_name }}\"\n_webapp_log_dir: \"/var/log/{{ webapp_name }}\"\n_webapp_pid_file: \"/var/run/{{ webapp_name }}.pid\"\n_webapp_config_dir: \"{{ webapp_home }}/config\"\n_webapp_temp_dir: \"/tmp/{{ webapp_name }}\"\n\n# Package lists by OS family\n_webapp_packages:\n  Debian:\n    - git\n    - curl\n    - build-essential\n    - python3-pip\n    - logrotate\n  RedHat:\n    - git\n    - curl\n    - gcc\n    - gcc-c++\n    - python3-pip\n    - logrotate\n\n# Service management\n_webapp_systemd_service: \"{{ _webapp_service_name }}.service\"\n_webapp_systemd_path: \"/etc/systemd/system/{{ _webapp_systemd_service }}\"\n\n---\n# roles/webapp/tasks/main.yml\n---\n- name: Include OS-specific variables\n  include_vars: \"{{ ansible_os_family }}.yml\"\n  tags: [always]\n\n- name: Validate configuration\n  include_tasks: validate.yml\n  tags: [validate]\n\n- name: Setup system prerequisites\n  include_tasks: prerequisites.yml\n  tags: [setup, prerequisites]\n\n- name: Create application user and directories\n  include_tasks: user.yml\n  tags: [setup, user]\n\n- name: Configure database\n  include_tasks: database.yml\n  when: webapp_database_type != \"none\"\n  tags: [database]\n\n- name: Deploy application code\n  include_tasks: deploy.yml\n  tags: [deploy]\n\n- name: Configure application\n  include_tasks: configure.yml\n  tags: [configure]\n\n- name: Setup web server\n  include_tasks: webserver.yml\n  tags: [webserver]\n\n- name: Configure monitoring\n  include_tasks: monitoring.yml\n  when: webapp_monitoring_enabled\n  tags: [monitoring]\n\n- name: Setup backup\n  include_tasks: backup.yml\n  when: webapp_backup_enabled\n  tags: [backup]\n\n- name: Configure security\n  include_tasks: security.yml\n  tags: [security]\n\n- name: Start and enable services\n  include_tasks: services.yml\n  tags: [services]\n\n- name: Run health checks\n  include_tasks: healthcheck.yml\n  tags: [healthcheck, verify]\n\n---\n# roles/webapp/tasks/deploy.yml\n---\n- name: Create temporary deployment directory\n  tempfile:\n    state: directory\n    prefix: \"{{ webapp_name }}_deploy_\"\n  register: deploy_temp_dir\n  changed_when: false\n\n- name: Clone application repository\n  git:\n    repo: \"{{ webapp_repo_url }}\"\n    dest: \"{{ deploy_temp_dir.path }}\"\n    version: \"{{ webapp_repo_version }}\"\n    key_file: \"{{ webapp_repo_key_file if webapp_repo_key_file else omit }}\"\n    force: yes\n  register: git_clone\n  notify: restart webapp\n\n- name: Install application dependencies\n  npm:\n    path: \"{{ deploy_temp_dir.path }}\"\n    state: present\n    production: \"{{ webapp_env == 'production' }}\"\n  when: git_clone.changed\n\n- name: Build application\n  command: npm run build\n  args:\n    chdir: \"{{ deploy_temp_dir.path }}\"\n  environment:\n    NODE_ENV: \"{{ webapp_env }}\"\n  when: git_clone.changed\n  register: build_result\n  failed_when: build_result.rc != 0\n\n- name: Run application tests\n  command: npm test\n  args:\n    chdir: \"{{ deploy_temp_dir.path }}\"\n  environment:\n    NODE_ENV: test\n  when: webapp_env != \"production\" and git_clone.changed\n  register: test_result\n  failed_when: test_result.rc != 0\n\n- name: Stop application service\n  systemd:\n    name: \"{{ _webapp_service_name }}\"\n    state: stopped\n  when: git_clone.changed\n  ignore_errors: true\n\n- name: Backup current application\n  archive:\n    path: \"{{ webapp_home }}\"\n    dest: \"{{ webapp_home }}.backup.{{ ansible_date_time.epoch }}.tar.gz\"\n    format: gz\n  when: git_clone.changed and webapp_backup_enabled\n\n- name: Deploy application files\n  synchronize:\n    src: \"{{ deploy_temp_dir.path }}/\"\n    dest: \"{{ webapp_home }}/\"\n    delete: yes\n    recursive: yes\n  become: yes\n  become_user: \"{{ webapp_user }}\"\n  when: git_clone.changed\n  notify: restart webapp\n\n- name: Set application file permissions\n  file:\n    path: \"{{ webapp_home }}\"\n    owner: \"{{ webapp_user }}\"\n    group: \"{{ webapp_group }}\"\n    mode: '0755'\n    recurse: yes\n  when: git_clone.changed\n\n- name: Remove temporary deployment directory\n  file:\n    path: \"{{ deploy_temp_dir.path }}\"\n    state: absent\n  changed_when: false\n\n---\n# roles/webapp/tasks/monitoring.yml\n---\n- name: Install monitoring dependencies\n  package:\n    name:\n      - prometheus-node-exporter\n      - grafana-agent\n    state: present\n\n- name: Configure Prometheus metrics endpoint\n  template:\n    src: prometheus-config.js.j2\n    dest: \"{{ webapp_home }}/config/prometheus.js\"\n    owner: \"{{ webapp_user }}\"\n    group: \"{{ webapp_group }}\"\n    mode: '0644'\n  notify: restart webapp\n\n- name: Configure Grafana agent\n  template:\n    src: grafana-agent.yml.j2\n    dest: /etc/grafana-agent.yml\n    mode: '0644'\n  notify: restart grafana-agent\n\n- name: Create monitoring dashboard\n  template:\n    src: webapp-dashboard.json.j2\n    dest: \"/var/lib/grafana/dashboards/{{ webapp_name }}-dashboard.json\"\n    mode: '0644'\n  notify: restart grafana\n\n- name: Configure log aggregation\n  template:\n    src: filebeat.yml.j2\n    dest: /etc/filebeat/filebeat.yml\n    mode: '0600'\n  notify: restart filebeat\n\n- name: Setup health check monitoring\n  template:\n    src: health-check.sh.j2\n    dest: \"/usr/local/bin/{{ webapp_name }}-health-check.sh\"\n    mode: '0755'\n\n- name: Create health check cron job\n  cron:\n    name: \"{{ webapp_name }} health check\"\n    minute: \"*/5\"\n    job: \"/usr/local/bin/{{ webapp_name }}-health-check.sh\"\n    user: root\n\n---\n# roles/webapp/handlers/main.yml\n---\n- name: restart webapp\n  systemd:\n    name: \"{{ _webapp_service_name }}\"\n    state: restarted\n    daemon_reload: yes\n  listen: restart webapp\n\n- name: reload nginx\n  systemd:\n    name: nginx\n    state: reloaded\n  listen: reload nginx\n\n- name: restart grafana-agent\n  systemd:\n    name: grafana-agent\n    state: restarted\n  listen: restart grafana-agent\n\n- name: restart grafana\n  systemd:\n    name: grafana-server\n    state: restarted\n  listen: restart grafana\n\n- name: restart filebeat\n  systemd:\n    name: filebeat\n    state: restarted\n  listen: restart filebeat\n\n---\n# roles/webapp/templates/nginx-vhost.conf.j2\nserver {\n    listen 80;\n    server_name {{ ansible_fqdn }} {{ ansible_hostname }};\n    \n{% if webapp_ssl_enabled %}\n    # Redirect HTTP to HTTPS\n    return 301 https://$server_name$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name {{ ansible_fqdn }} {{ ansible_hostname }};\n    \n    # SSL Configuration\n    ssl_certificate {{ webapp_ssl_cert_path }};\n    ssl_certificate_key {{ webapp_ssl_key_path }};\n    ssl_protocols {{ webapp_ssl_protocols }};\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;\n    ssl_prefer_server_ciphers on;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    \n{% if webapp_security_headers_enabled %}\n    # Security Headers\n    add_header X-Frame-Options \"SAMEORIGIN\" always;\n    add_header X-Content-Type-Options \"nosniff\" always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n    add_header Referrer-Policy \"no-referrer-when-downgrade\" always;\n    add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always;\n{% endif %}\n{% endif %}\n    \n    # Basic Configuration\n    client_max_body_size {{ webapp_nginx_client_max_body_size }};\n    keepalive_timeout {{ webapp_nginx_keepalive_timeout }};\n    \n{% if webapp_gzip_enabled %}\n    # Gzip Compression\n    gzip on;\n    gzip_comp_level 6;\n    gzip_types\n        text/plain\n        text/css\n        text/xml\n        text/javascript\n        application/json\n        application/javascript\n        application/xml+rss\n        application/atom+xml\n        image/svg+xml;\n{% endif %}\n    \n    # Static Files\n    location /static/ {\n        alias {{ webapp_home }}/public/;\n        expires {{ webapp_static_cache_duration }};\n        add_header Cache-Control \"public, immutable\";\n    }\n    \n    # Health Check\n    location {{ webapp_health_check_path }} {\n        proxy_pass http://127.0.0.1:{{ webapp_port }}{{ webapp_health_check_path }};\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        access_log off;\n    }\n    \n    # Metrics Endpoint (restrict access)\n    location /metrics {\n        proxy_pass http://127.0.0.1:{{ webapp_metrics_port }}/metrics;\n        allow 127.0.0.1;\n        allow {{ hostvars[groups['monitoring'][0]]['ansible_default_ipv4']['address'] if groups['monitoring'] is defined else '127.0.0.1' }};\n        deny all;\n    }\n    \n    # Application Proxy\n    location / {\n        proxy_pass http://127.0.0.1:{{ webapp_port }};\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        \n        # WebSocket support\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        \n        # Timeouts\n        proxy_connect_timeout 60s;\n        proxy_send_timeout 60s;\n        proxy_read_timeout 60s;\n    }\n    \n{% if webapp_access_log_enabled %}\n    # Logging\n    access_log /var/log/nginx/{{ webapp_name }}_access.log combined;\n{% else %}\n    access_log off;\n{% endif %}\n    error_log /var/log/nginx/{{ webapp_name }}_error.log;\n}\n\n---\n# roles/webapp/templates/ecosystem.config.js.j2\nmodule.exports = {\n  apps: [{\n    name: '{{ webapp_name }}',\n    script: './app.js',\n    cwd: '{{ webapp_home }}',\n    instances: {{ webapp_pm2_instances }},\n    exec_mode: 'cluster',\n    max_memory_restart: '{{ webapp_pm2_max_memory_restart }}',\n    max_restarts: {{ webapp_pm2_max_restarts }},\n    min_uptime: '{{ webapp_pm2_min_uptime }}',\n    \n    env: {\n      NODE_ENV: '{{ webapp_env }}',\n      PORT: {{ webapp_port }},\n      DATABASE_URL: '{{ webapp_database_type }}://{{ webapp_database_user }}:{{ webapp_database_password }}@{{ webapp_database_host }}:{{ webapp_database_port }}/{{ webapp_database_name }}',\n      LOG_LEVEL: '{{ webapp_log_level }}',\n      METRICS_PORT: {{ webapp_metrics_port }}\n    },\n    \n    log_date_format: 'YYYY-MM-DD HH:mm:ss Z',\n    out_file: '{{ _webapp_log_dir }}/app.log',\n    error_file: '{{ _webapp_log_dir }}/error.log',\n    log_file: '{{ _webapp_log_dir }}/combined.log',\n    \n    merge_logs: true,\n    log_type: 'json',\n    \n    watch: false,\n    ignore_watch: [\n      'node_modules',\n      'logs',\n      'public'\n    ],\n    \n    kill_timeout: 5000,\n    wait_ready: true,\n    listen_timeout: 10000\n  }]\n};",
      "language": "yaml",
      "scenario": "Production-ready web application role with comprehensive configuration management, monitoring, and security"
    },
    {
      "title": "Custom Collection Development",
      "description": "Complete collection structure with custom modules, plugins, and roles",
      "code": "# galaxy.yml - Collection metadata\n---\nnamespace: mycompany\nname: infrastructure\nversion: 1.0.0\nreadme: README.md\nauthors:\n  - DevOps Team <devops@mycompany.com>\ndescription: >\n  Comprehensive infrastructure automation collection for MyCompany\n  including custom modules, plugins, and roles for cloud and on-premises deployment.\nlicense_file: LICENSE\ntags:\n  - infrastructure\n  - cloud\n  - automation\n  - security\n  - monitoring\ndependencies:\n  \"amazon.aws\": \">=3.0.0\"\n  \"kubernetes.core\": \">=2.0.0\"\n  \"community.general\": \">=4.0.0\"\n  \"ansible.posix\": \">=1.0.0\"\nrepository: https://github.com/mycompany/ansible-infrastructure\ndocumentation: https://docs.mycompany.com/ansible\nhomepage: https://github.com/mycompany/ansible-infrastructure\nissues: https://github.com/mycompany/ansible-infrastructure/issues\nbuild_ignore:\n  - .git\n  - .github\n  - .gitignore\n  - .DS_Store\n  - tests/output\n  - \".pytest_cache\"\n  - \"*.pyc\"\n  - \"*.pyo\"\n  - \"*.pyd\"\n  - \"__pycache__\"\n  - \".tox\"\n  - \".coverage\"\n  - \".coveragerc\"\n  - \"docs/_build\"\n\n---\n# plugins/modules/custom_service_check.py\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2023, MyCompany DevOps Team\n# GNU General Public License v3.0+\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nDOCUMENTATION = '''\n---\nmodule: custom_service_check\nshort_description: Check service health and dependencies\ndescription:\n    - Performs comprehensive health checks on services\n    - Validates service dependencies and connectivity\n    - Reports detailed status information\nversion_added: \"1.0.0\"\noptions:\n    service_name:\n        description:\n            - Name of the service to check\n        required: true\n        type: str\n    port:\n        description:\n            - Port number to check\n        required: true\n        type: int\n    host:\n        description:\n            - Host to check (default: localhost)\n        required: false\n        type: str\n        default: localhost\n    timeout:\n        description:\n            - Connection timeout in seconds\n        required: false\n        type: int\n        default: 10\n    dependencies:\n        description:\n            - List of service dependencies to check\n        required: false\n        type: list\n        elements: dict\n        suboptions:\n            name:\n                description: Dependency service name\n                type: str\n                required: true\n            host:\n                description: Dependency host\n                type: str\n                required: true\n            port:\n                description: Dependency port\n                type: int\n                required: true\n    health_endpoint:\n        description:\n            - HTTP endpoint for health checks\n        required: false\n        type: str\n    expected_response:\n        description:\n            - Expected response from health endpoint\n        required: false\n        type: str\n        default: \"healthy\"\nauthor:\n    - MyCompany DevOps Team (@mycompany-devops)\n'''\n\nEXAMPLES = '''\n- name: Check web service health\n  mycompany.infrastructure.custom_service_check:\n    service_name: nginx\n    port: 80\n    health_endpoint: \"/health\"\n    dependencies:\n      - name: database\n        host: db.example.com\n        port: 3306\n      - name: redis\n        host: cache.example.com\n        port: 6379\n\n- name: Check API service with custom timeout\n  mycompany.infrastructure.custom_service_check:\n    service_name: api\n    port: 8080\n    host: api.example.com\n    timeout: 30\n    health_endpoint: \"/api/health\"\n    expected_response: \"OK\"\n'''\n\nRETURN = '''\nservice_status:\n    description: Overall service status\n    returned: always\n    type: str\n    sample: \"healthy\"\nport_check:\n    description: Port connectivity status\n    returned: always\n    type: bool\n    sample: true\nhealth_check:\n    description: Health endpoint response\n    returned: when health_endpoint is provided\n    type: dict\n    sample:\n        status_code: 200\n        response: \"healthy\"\n        response_time: 0.123\ndependency_status:\n    description: Status of service dependencies\n    returned: when dependencies are provided\n    type: dict\n    sample:\n        database:\n            status: \"connected\"\n            response_time: 0.045\n        redis:\n            status: \"connected\"\n            response_time: 0.012\n'''\n\nimport socket\nimport time\nimport json\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.urls import fetch_url\n\ndef check_port_connectivity(host, port, timeout):\n    \"\"\"Check if port is accessible\"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(timeout)\n        result = sock.connect_ex((host, port))\n        sock.close()\n        return result == 0\n    except Exception:\n        return False\n\ndef check_health_endpoint(module, host, port, endpoint, expected_response, timeout):\n    \"\"\"Check HTTP health endpoint\"\"\"\n    url = f\"http://{host}:{port}{endpoint}\"\n    start_time = time.time()\n    \n    try:\n        response, info = fetch_url(module, url, timeout=timeout)\n        response_time = time.time() - start_time\n        \n        if response:\n            content = response.read().decode('utf-8')\n            return {\n                'status_code': info['status'],\n                'response': content,\n                'response_time': round(response_time, 3),\n                'healthy': expected_response in content\n            }\n        else:\n            return {\n                'status_code': info.get('status', 0),\n                'response': '',\n                'response_time': round(response_time, 3),\n                'healthy': False,\n                'error': info.get('msg', 'Unknown error')\n            }\n    except Exception as e:\n        return {\n            'status_code': 0,\n            'response': '',\n            'response_time': round(time.time() - start_time, 3),\n            'healthy': False,\n            'error': str(e)\n        }\n\ndef check_dependencies(module, dependencies, timeout):\n    \"\"\"Check service dependencies\"\"\"\n    results = {}\n    \n    for dep in dependencies:\n        name = dep['name']\n        host = dep['host']\n        port = dep['port']\n        \n        start_time = time.time()\n        connected = check_port_connectivity(host, port, timeout)\n        response_time = time.time() - start_time\n        \n        results[name] = {\n            'status': 'connected' if connected else 'failed',\n            'response_time': round(response_time, 3)\n        }\n    \n    return results\n\ndef main():\n    module_args = dict(\n        service_name=dict(type='str', required=True),\n        port=dict(type='int', required=True),\n        host=dict(type='str', required=False, default='localhost'),\n        timeout=dict(type='int', required=False, default=10),\n        dependencies=dict(type='list', required=False, default=[]),\n        health_endpoint=dict(type='str', required=False),\n        expected_response=dict(type='str', required=False, default='healthy')\n    )\n    \n    module = AnsibleModule(\n        argument_spec=module_args,\n        supports_check_mode=True\n    )\n    \n    service_name = module.params['service_name']\n    port = module.params['port']\n    host = module.params['host']\n    timeout = module.params['timeout']\n    dependencies = module.params['dependencies']\n    health_endpoint = module.params['health_endpoint']\n    expected_response = module.params['expected_response']\n    \n    result = {\n        'changed': False,\n        'service_name': service_name\n    }\n    \n    if module.check_mode:\n        module.exit_json(**result)\n    \n    # Check port connectivity\n    port_accessible = check_port_connectivity(host, port, timeout)\n    result['port_check'] = port_accessible\n    \n    # Check health endpoint if provided\n    if health_endpoint and port_accessible:\n        health_result = check_health_endpoint(\n            module, host, port, health_endpoint, expected_response, timeout\n        )\n        result['health_check'] = health_result\n        service_healthy = health_result['healthy']\n    else:\n        service_healthy = port_accessible\n    \n    # Check dependencies\n    if dependencies:\n        dep_results = check_dependencies(module, dependencies, timeout)\n        result['dependency_status'] = dep_results\n        \n        # Service is healthy only if all dependencies are connected\n        all_deps_healthy = all(\n            dep['status'] == 'connected' for dep in dep_results.values()\n        )\n        service_healthy = service_healthy and all_deps_healthy\n    \n    # Set overall status\n    result['service_status'] = 'healthy' if service_healthy else 'unhealthy'\n    \n    if not service_healthy:\n        module.fail_json(msg=f\"Service {service_name} is unhealthy\", **result)\n    \n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n\n---\n# plugins/filter/infrastructure_filters.py\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2023, MyCompany DevOps Team\n# GNU General Public License v3.0+\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    name: infrastructure_filters\n    author: MyCompany DevOps Team\n    version_added: \"1.0.0\"\n    short_description: Custom filters for infrastructure automation\n    description:\n        - Provides custom Jinja2 filters for infrastructure tasks\n        - Includes network, security, and utility filters\n'''\n\nimport ipaddress\nimport hashlib\nimport re\nfrom ansible.errors import AnsibleFilterError\n\ndef get_network_info(ip_with_prefix):\n    \"\"\"Extract network information from IP/CIDR\"\"\"\n    try:\n        network = ipaddress.ip_network(ip_with_prefix, strict=False)\n        return {\n            'network': str(network.network_address),\n            'netmask': str(network.netmask),\n            'broadcast': str(network.broadcast_address),\n            'prefix': network.prefixlen,\n            'num_hosts': network.num_addresses - 2 if network.num_addresses > 2 else 0\n        }\n    except ValueError as e:\n        raise AnsibleFilterError(f\"Invalid IP/CIDR format: {e}\")\n\ndef generate_password(length=16, include_special=True):\n    \"\"\"Generate secure random password\"\"\"\n    import secrets\n    import string\n    \n    chars = string.ascii_letters + string.digits\n    if include_special:\n        chars += \"!@#$%^&*\"\n    \n    return ''.join(secrets.choice(chars) for _ in range(length))\n\ndef hash_string(text, algorithm='sha256'):\n    \"\"\"Hash string using specified algorithm\"\"\"\n    try:\n        hasher = hashlib.new(algorithm)\n        hasher.update(text.encode('utf-8'))\n        return hasher.hexdigest()\n    except ValueError:\n        raise AnsibleFilterError(f\"Unsupported hash algorithm: {algorithm}\")\n\ndef sanitize_name(name):\n    \"\"\"Sanitize name for use in resources\"\"\"\n    # Remove special characters and convert to lowercase\n    sanitized = re.sub(r'[^a-zA-Z0-9-]', '-', name.lower())\n    # Remove multiple consecutive hyphens\n    sanitized = re.sub(r'-+', '-', sanitized)\n    # Remove leading/trailing hyphens\n    return sanitized.strip('-')\n\ndef calculate_subnet(base_network, subnet_count, subnet_index):\n    \"\"\"Calculate subnet from base network\"\"\"\n    try:\n        base = ipaddress.ip_network(base_network)\n        subnets = list(base.subnets(new_prefix=base.prefixlen + subnet_count.bit_length()))\n        \n        if subnet_index >= len(subnets):\n            raise AnsibleFilterError(f\"Subnet index {subnet_index} out of range\")\n        \n        return str(subnets[subnet_index])\n    except ValueError as e:\n        raise AnsibleFilterError(f\"Invalid network calculation: {e}\")\n\ndef format_bytes(bytes_value, binary=False):\n    \"\"\"Format bytes into human readable format\"\"\"\n    try:\n        bytes_value = int(bytes_value)\n        base = 1024 if binary else 1000\n        units = ['B', 'KB', 'MB', 'GB', 'TB'] if not binary else ['B', 'KiB', 'MiB', 'GiB', 'TiB']\n        \n        for unit in units:\n            if bytes_value < base:\n                return f\"{bytes_value:.1f} {unit}\"\n            bytes_value /= base\n        \n        return f\"{bytes_value:.1f} {units[-1]}\"\n    except (ValueError, TypeError):\n        raise AnsibleFilterError(\"Invalid bytes value\")\n\ndef extract_domain(url_or_fqdn):\n    \"\"\"Extract domain from URL or FQDN\"\"\"\n    # Remove protocol if present\n    domain = re.sub(r'^https?://', '', url_or_fqdn)\n    # Remove path if present\n    domain = domain.split('/')[0]\n    # Remove port if present\n    domain = domain.split(':')[0]\n    return domain\n\ndef generate_csr_subject(common_name, organization=None, country=None, state=None, city=None):\n    \"\"\"Generate certificate subject string\"\"\"\n    subject_parts = [f\"CN={common_name}\"]\n    \n    if organization:\n        subject_parts.append(f\"O={organization}\")\n    if country:\n        subject_parts.append(f\"C={country}\")\n    if state:\n        subject_parts.append(f\"ST={state}\")\n    if city:\n        subject_parts.append(f\"L={city}\")\n    \n    return \"/\" + \"/\".join(subject_parts)\n\nclass FilterModule(object):\n    \"\"\"Custom filter module\"\"\"\n    \n    def filters(self):\n        return {\n            'network_info': get_network_info,\n            'generate_password': generate_password,\n            'hash_string': hash_string,\n            'sanitize_name': sanitize_name,\n            'calculate_subnet': calculate_subnet,\n            'format_bytes': format_bytes,\n            'extract_domain': extract_domain,\n            'csr_subject': generate_csr_subject\n        }\n\n---\n# roles/infrastructure_base/meta/main.yml\n---\ngalaxy_info:\n  role_name: infrastructure_base\n  author: MyCompany DevOps Team\n  description: Base infrastructure configuration for all servers\n  company: MyCompany\n  license: MIT\n  min_ansible_version: 2.9\n  platforms:\n    - name: Ubuntu\n      versions:\n        - focal\n        - jammy\n    - name: CentOS\n      versions:\n        - 7\n        - 8\n        - 9\n  galaxy_tags:\n    - infrastructure\n    - base\n    - security\n    - monitoring\n\ncollections:\n  - mycompany.infrastructure\n\ndependencies: []\n\n---\n# requirements.yml - Collection dependencies\n---\ncollections:\n  # Core collections\n  - name: ansible.posix\n    version: \">=1.4.0\"\n  - name: community.general\n    version: \">=5.0.0\"\n  - name: community.crypto\n    version: \">=2.0.0\"\n  \n  # Cloud providers\n  - name: amazon.aws\n    version: \">=4.0.0\"\n  - name: azure.azcollection\n    version: \">=1.13.0\"\n  - name: google.cloud\n    version: \">=1.0.0\"\n  \n  # Container and orchestration\n  - name: kubernetes.core\n    version: \">=2.3.0\"\n  - name: containers.podman\n    version: \">=1.9.0\"\n  \n  # Monitoring and observability\n  - name: prometheus.prometheus\n    version: \">=0.8.0\"\n  - name: grafana.grafana\n    version: \">=1.1.0\"\n  \n  # Security\n  - name: community.hashi_vault\n    version: \">=3.0.0\"\n  \n  # Custom collections\n  - name: mycompany.infrastructure\n    version: \">=1.0.0\"\n    source: https://galaxy.mycompany.com/\n\nroles:\n  # Infrastructure roles\n  - name: geerlingguy.nginx\n    version: 2.8.0\n  - name: geerlingguy.mysql\n    version: 4.3.2\n  - name: geerlingguy.redis\n    version: 1.7.0\n  - name: geerlingguy.docker\n    version: 6.1.0\n  \n  # Security roles\n  - name: dev-sec.os-hardening\n    version: 7.10.0\n  - name: dev-sec.ssh-hardening\n    version: 9.8.0\n  \n  # Monitoring roles\n  - name: cloudalchemy.prometheus\n    version: 2.17.4\n  - name: cloudalchemy.grafana\n    version: 0.22.3\n  - name: cloudalchemy.node-exporter\n    version: 3.0.0\n\n---\n# playbooks/site.yml - Main site playbook using collection\n---\n- name: Deploy Infrastructure\n  hosts: all\n  gather_facts: true\n  collections:\n    - mycompany.infrastructure\n  \n  pre_tasks:\n    - name: Validate host connectivity\n      custom_service_check:\n        service_name: ssh\n        port: 22\n        timeout: 5\n      delegate_to: localhost\n  \n  roles:\n    - role: infrastructure_base\n      vars:\n        security_hardening: true\n        monitoring_enabled: true\n    \n    - role: webapp\n      when: \"'webservers' in group_names\"\n      vars:\n        webapp_name: \"{{ application_name }}\"\n        webapp_version: \"{{ application_version | default('latest') }}\"\n  \n  tasks:\n    - name: Generate secure passwords\n      set_fact:\n        db_password: \"{{ 'mysecretbase' | hash_string('sha256') | generate_password(24) }}\"\n      no_log: true\n    \n    - name: Calculate network subnets\n      set_fact:\n        app_subnet: \"{{ '10.0.0.0/16' | calculate_subnet(4, 1) }}\"\n        db_subnet: \"{{ '10.0.0.0/16' | calculate_subnet(4, 2) }}\"\n    \n    - name: Format server information\n      debug:\n        msg: |\n          Server: {{ inventory_hostname | sanitize_name }}\n          Memory: {{ ansible_memtotal_mb | int * 1024 * 1024 | format_bytes(true) }}\n          Domain: {{ ansible_fqdn | extract_domain }}\n          Network: {{ ansible_default_ipv4.address }}/{{ ansible_default_ipv4.netmask | network_info }}\n  \n  post_tasks:\n    - name: Final health check\n      custom_service_check:\n        service_name: \"{{ webapp_name | default('system') }}\"\n        port: \"{{ webapp_port | default(80) }}\"\n        health_endpoint: \"/health\"\n      when: \"'webservers' in group_names\"",
      "language": "python",
      "scenario": "Complete custom collection with modules, filters, roles, and comprehensive infrastructure automation"
    }
  ],
  "troubleshooting": [
    {
      "problem": "Role dependencies not installing correctly",
      "solution": "Check requirements.yml format and use ansible-galaxy install with --force flag",
      "commands": ["ansible-galaxy install -r requirements.yml --force", "ansible-galaxy list"],
      "details": "Ensure proper YAML format and version specifications in requirements files"
    },
    {
      "problem": "Collection module not found after installation",
      "solution": "Verify collection installation path and use fully qualified collection names (FQCN)",
      "commands": ["ansible-galaxy collection list", "ansible-config dump | grep COLLECTIONS_PATHS"],
      "details": "Use namespace.collection.module_name format and check ansible.cfg collection paths"
    },
    {
      "problem": "Role variable precedence issues",
      "solution": "Review variable precedence order and use appropriate variable types (defaults vs vars)",
      "commands": ["ansible-playbook --extra-vars", "ansible-inventory --host hostname"],
      "details": "Extra vars > host vars > group vars > role vars > role defaults"
    },
    {
      "problem": "Collection build or publish failures",
      "solution": "Validate galaxy.yml format and check authentication for private Galaxy servers",
      "commands": ["ansible-galaxy collection build --force", "ansible-galaxy collection verify"],
      "details": "Ensure all required metadata fields are present and version format is correct"
    }
  ],
  "tags": ["roles", "collections", "reusability", "modular", "galaxy", "packages", "dependencies"]
}
