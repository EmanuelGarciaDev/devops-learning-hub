{
  "id": "build-automation",
  "toolId": "jenkins",
  "name": "Build Automation",
  "description": "Advanced build automation patterns, testing strategies, and deployment workflows",
  "difficulty": "intermediate",
  "definitions": {
    "beginner": "Build automation in Jenkins means setting up jobs that automatically compile, test, and package your code whenever changes are made, eliminating manual steps and reducing errors.",
    "advanced": "Build automation encompasses comprehensive CI/CD workflows including multi-stage builds, parallel testing strategies, artifact management, dependency scanning, deployment automation, and feedback mechanisms with integration to external tools and notification systems."
  },
  "commands": [
    {
      "command": "jenkins-cli build",
      "description": "Trigger builds via Jenkins CLI",
      "example": "java -jar jenkins-cli.jar -s http://localhost:8080/ build my-job -p ENVIRONMENT=staging",
      "flags": [
        {
          "flag": "-p",
          "description": "Pass parameters to parameterized builds",
          "example": "-p BRANCH=feature/new-feature"
        },
        {
          "flag": "-s",
          "description": "Follow build output in console",
          "example": "-s"
        },
        {
          "flag": "-w",
          "description": "Wait for build to complete",
          "example": "-w"
        }
      ]
    },
    {
      "command": "curl build trigger",
      "description": "Trigger builds via REST API",
      "example": "curl -X POST http://jenkins:token@localhost:8080/job/my-job/buildWithParameters?ENVIRONMENT=prod"
    }
  ],
  "examples": [
    {
      "title": "Multi-Language Monorepo Build",
      "description": "Automated build system for monorepo with multiple languages and selective building",
      "code": "pipeline {\n    agent {\n        kubernetes {\n            yaml \"\"\"\n                apiVersion: v1\n                kind: Pod\n                spec:\n                  containers:\n                  - name: node\n                    image: node:18-alpine\n                    command: ['cat']\n                    tty: true\n                  - name: python\n                    image: python:3.11-slim\n                    command: ['cat']\n                    tty: true\n                  - name: java\n                    image: maven:3.8.4-openjdk-11\n                    command: ['cat']\n                    tty: true\n                  - name: docker\n                    image: docker:20.10.12-dind\n                    securityContext:\n                      privileged: true\n            \"\"\"\n        }\n    }\n    \n    environment {\n        ARTIFACTORY_URL = 'https://artifactory.company.com'\n        NEXUS_CREDENTIALS = credentials('nexus-credentials')\n        BUILD_CACHE_ENABLED = 'true'\n    }\n    \n    stages {\n        stage('Change Detection') {\n            steps {\n                script {\n                    def changes = sh(\n                        script: '''\n                            if [ \"$CHANGE_ID\" ]; then\n                                git diff --name-only origin/$CHANGE_TARGET HEAD\n                            else\n                                git diff --name-only HEAD~1 HEAD\n                            fi\n                        ''',\n                        returnStdout: true\n                    ).trim().split('\\n')\n                    \n                    env.BUILD_FRONTEND = changes.any { it.startsWith('frontend/') } ? 'true' : 'false'\n                    env.BUILD_BACKEND = changes.any { it.startsWith('backend/') } ? 'true' : 'false'\n                    env.BUILD_API = changes.any { it.startsWith('api/') } ? 'true' : 'false'\n                    env.BUILD_SHARED = changes.any { it.startsWith('shared/') } ? 'true' : 'false'\n                    \n                    echo \"Build plan: Frontend=${env.BUILD_FRONTEND}, Backend=${env.BUILD_BACKEND}, API=${env.BUILD_API}, Shared=${env.BUILD_SHARED}\"\n                }\n            }\n        }\n        \n        stage('Build & Test') {\n            parallel {\n                stage('Frontend (React/TypeScript)') {\n                    when {\n                        expression { env.BUILD_FRONTEND == 'true' || env.BUILD_SHARED == 'true' }\n                    }\n                    steps {\n                        container('node') {\n                            dir('frontend') {\n                                script {\n                                    // Cache management\n                                    def cacheKey = \"frontend-${hashFiles('package-lock.json')}\"\n                                    def cacheHit = sh(\n                                        script: \"curl -f ${ARTIFACTORY_URL}/cache/${cacheKey}.tar.gz -o cache.tar.gz\",\n                                        returnStatus: true\n                                    ) == 0\n                                    \n                                    if (cacheHit) {\n                                        sh 'tar -xzf cache.tar.gz'\n                                        echo 'Cache hit: node_modules restored'\n                                    } else {\n                                        sh 'npm ci'\n                                        sh \"tar -czf ${cacheKey}.tar.gz node_modules\"\n                                        sh \"curl -T ${cacheKey}.tar.gz ${ARTIFACTORY_URL}/cache/\"\n                                        echo 'Cache miss: dependencies installed and cached'\n                                    }\n                                }\n                                \n                                // Parallel testing strategies\n                                parallel(\n                                    'Unit Tests': {\n                                        sh 'npm run test:unit -- --coverage --watchAll=false'\n                                        publishHTML([\n                                            allowMissing: false,\n                                            alwaysLinkToLastBuild: true,\n                                            keepAll: true,\n                                            reportDir: 'coverage/lcov-report',\n                                            reportFiles: 'index.html',\n                                            reportName: 'Frontend Coverage Report'\n                                        ])\n                                    },\n                                    'Integration Tests': {\n                                        sh 'npm run test:integration'\n                                    },\n                                    'E2E Tests': {\n                                        sh '''\n                                            npm run build\n                                            npm run serve &\n                                            sleep 10\n                                            npm run test:e2e -- --headless\n                                        '''\n                                    },\n                                    'Lint & Type Check': {\n                                        sh 'npm run lint'\n                                        sh 'npm run type-check'\n                                    },\n                                    'Security Audit': {\n                                        sh 'npm audit --audit-level=moderate'\n                                        sh 'npx snyk test --severity-threshold=high'\n                                    }\n                                )\n                                \n                                // Build and optimize\n                                sh '''\n                                    npm run build\n                                    npm run analyze -- --json > bundle-analysis.json\n                                '''\n                                \n                                // Performance budgets\n                                script {\n                                    def bundleSize = sh(\n                                        script: \"du -sb dist/ | cut -f1\",\n                                        returnStdout: true\n                                    ).trim() as Integer\n                                    \n                                    def maxSize = 5 * 1024 * 1024 // 5MB\n                                    if (bundleSize > maxSize) {\n                                        error \"Bundle size ${bundleSize} exceeds maximum ${maxSize}\"\n                                    }\n                                    echo \"Bundle size: ${bundleSize} bytes (within budget)\"\n                                }\n                                \n                                archiveArtifacts 'dist/**, bundle-analysis.json'\n                            }\n                        }\n                    }\n                }\n                \n                stage('Backend (Python/FastAPI)') {\n                    when {\n                        expression { env.BUILD_BACKEND == 'true' || env.BUILD_SHARED == 'true' }\n                    }\n                    steps {\n                        container('python') {\n                            dir('backend') {\n                                sh '''\n                                    python -m venv venv\n                                    . venv/bin/activate\n                                    pip install --upgrade pip\n                                    pip install -r requirements.txt -r requirements-dev.txt\n                                '''\n                                \n                                parallel(\n                                    'Unit Tests': {\n                                        sh '''\n                                            . venv/bin/activate\n                                            pytest tests/unit/ -v --cov=src --cov-report=html --cov-report=xml\n                                        '''\n                                        publishHTML([\n                                            allowMissing: false,\n                                            alwaysLinkToLastBuild: true,\n                                            keepAll: true,\n                                            reportDir: 'htmlcov',\n                                            reportFiles: 'index.html',\n                                            reportName: 'Backend Coverage Report'\n                                        ])\n                                    },\n                                    'Integration Tests': {\n                                        sh '''\n                                            . venv/bin/activate\n                                            docker-compose -f docker-compose.test.yml up -d postgres redis\n                                            sleep 5\n                                            pytest tests/integration/ -v\n                                            docker-compose -f docker-compose.test.yml down\n                                        '''\n                                    },\n                                    'Code Quality': {\n                                        sh '''\n                                            . venv/bin/activate\n                                            black --check src/\n                                            isort --check-only src/\n                                            flake8 src/\n                                            mypy src/\n                                        '''\n                                    },\n                                    'Security Scan': {\n                                        sh '''\n                                            . venv/bin/activate\n                                            bandit -r src/ -f json -o bandit-report.json\n                                            safety check --json --output safety-report.json\n                                        '''\n                                        archiveArtifacts 'bandit-report.json, safety-report.json'\n                                    }\n                                )\n                                \n                                // Build wheel package\n                                sh '''\n                                    . venv/bin/activate\n                                    python setup.py bdist_wheel\n                                '''\n                                \n                                archiveArtifacts 'dist/*.whl'\n                            }\n                        }\n                    }\n                }\n                \n                stage('API Gateway (Java/Spring)') {\n                    when {\n                        expression { env.BUILD_API == 'true' || env.BUILD_SHARED == 'true' }\n                    }\n                    steps {\n                        container('java') {\n                            dir('api-gateway') {\n                                // Gradle build with caching\n                                sh '''\n                                    ./gradlew clean build \\\n                                      --build-cache \\\n                                      --parallel \\\n                                      --continue \\\n                                      -Dorg.gradle.jvmargs=\"-Xmx2g -XX:MaxMetaspaceSize=512m\"\n                                '''\n                                \n                                parallel(\n                                    'Unit Tests': {\n                                        sh './gradlew test'\n                                        junit 'build/test-results/test/*.xml'\n                                        publishHTML([\n                                            allowMissing: false,\n                                            alwaysLinkToLastBuild: true,\n                                            keepAll: true,\n                                            reportDir: 'build/reports/jacoco/test/html',\n                                            reportFiles: 'index.html',\n                                            reportName: 'API Gateway Coverage Report'\n                                        ])\n                                    },\n                                    'Integration Tests': {\n                                        sh './gradlew integrationTest'\n                                        junit 'build/test-results/integrationTest/*.xml'\n                                    },\n                                    'Contract Tests': {\n                                        sh './gradlew contractTest'\n                                        archiveArtifacts 'build/pacts/*.json'\n                                    },\n                                    'Code Quality': {\n                                        sh './gradlew sonarqube -Dsonar.pullrequest.key=${CHANGE_ID}'\n                                    }\n                                )\n                                \n                                archiveArtifacts 'build/libs/*.jar'\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Container Builds') {\n            when {\n                anyOf {\n                    expression { env.BUILD_FRONTEND == 'true' }\n                    expression { env.BUILD_BACKEND == 'true' }\n                    expression { env.BUILD_API == 'true' }\n                }\n            }\n            parallel {\n                stage('Frontend Container') {\n                    when {\n                        expression { env.BUILD_FRONTEND == 'true' }\n                    }\n                    steps {\n                        container('docker') {\n                            dir('frontend') {\n                                script {\n                                    def image = docker.build(\n                                        \"frontend:${BUILD_NUMBER}\",\n                                        \"--build-arg BUILD_VERSION=${BUILD_NUMBER} .\"\n                                    )\n                                    \n                                    // Multi-arch build\n                                    sh '''\n                                        docker buildx create --name multiarch --use\n                                        docker buildx build \\\n                                          --platform linux/amd64,linux/arm64 \\\n                                          --build-arg BUILD_VERSION=${BUILD_NUMBER} \\\n                                          -t frontend:${BUILD_NUMBER} \\\n                                          --push .\n                                    '''\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                stage('Backend Container') {\n                    when {\n                        expression { env.BUILD_BACKEND == 'true' }\n                    }\n                    steps {\n                        container('docker') {\n                            dir('backend') {\n                                sh '''\n                                    # Multi-stage build for optimization\n                                    docker build \\\n                                      --target production \\\n                                      --build-arg BUILD_VERSION=${BUILD_NUMBER} \\\n                                      -t backend:${BUILD_NUMBER} .\n                                    \n                                    # Security scan\n                                    trivy image --exit-code 1 --severity HIGH,CRITICAL backend:${BUILD_NUMBER}\n                                '''\n                            }\n                        }\n                    }\n                }\n                \n                stage('API Gateway Container') {\n                    when {\n                        expression { env.BUILD_API == 'true' }\n                    }\n                    steps {\n                        container('docker') {\n                            dir('api-gateway') {\n                                sh '''\n                                    docker build -t api-gateway:${BUILD_NUMBER} .\n                                    \n                                    # Image optimization\n                                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \\\n                                      wagoodman/dive api-gateway:${BUILD_NUMBER} \\\n                                      --ci --lowestEfficiency=0.95\n                                '''\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Artifact Publishing') {\n            steps {\n                script {\n                    parallel(\n                        'Publish to Artifactory': {\n                            if (env.BUILD_FRONTEND == 'true') {\n                                sh '''\n                                    cd frontend\n                                    npm publish --registry=${ARTIFACTORY_URL}/npm-local/\n                                '''\n                            }\n                            \n                            if (env.BUILD_BACKEND == 'true') {\n                                sh '''\n                                    cd backend\n                                    . venv/bin/activate\n                                    twine upload dist/*.whl --repository-url ${ARTIFACTORY_URL}/pypi-local/\n                                '''\n                            }\n                            \n                            if (env.BUILD_API == 'true') {\n                                sh '''\n                                    cd api-gateway\n                                    ./gradlew publish -PpublishUrl=${ARTIFACTORY_URL}/maven-local/\n                                '''\n                            }\n                        },\n                        'Push Container Images': {\n                            script {\n                                def services = []\n                                if (env.BUILD_FRONTEND == 'true') services.add('frontend')\n                                if (env.BUILD_BACKEND == 'true') services.add('backend')\n                                if (env.BUILD_API == 'true') services.add('api-gateway')\n                                \n                                services.each { service ->\n                                    docker.withRegistry('https://registry.company.com', 'docker-registry-credentials') {\n                                        def image = docker.image(\"${service}:${BUILD_NUMBER}\")\n                                        image.push()\n                                        image.push('latest')\n                                    }\n                                }\n                            }\n                        }\n                    )\n                }\n            }\n        }\n    }\n    \n    post {\n        always {\n            // Aggregate test results\n            publishTestResults testResultsPattern: '**/build/test-results/**/*.xml, **/target/surefire-reports/*.xml'\n            \n            // Cleanup\n            sh '''\n                docker system prune -f\n                rm -rf */node_modules */venv\n            '''\n        }\n        success {\n            script {\n                // Trigger downstream jobs\n                if (env.BRANCH_NAME == 'main') {\n                    build job: 'deploy-to-staging', \n                          parameters: [string(name: 'BUILD_VERSION', value: env.BUILD_NUMBER)],\n                          wait: false\n                }\n            }\n        }\n    }\n}",
      "language": "groovy",
      "scenario": "Comprehensive monorepo build automation with selective building, parallel testing, and artifact management"
    },
    {
      "title": "Dependency Management & Vulnerability Scanning",
      "description": "Automated dependency updates and security scanning pipeline",
      "code": "pipeline {\n    agent any\n    \n    triggers {\n        cron('H 2 * * 1')  // Weekly dependency check\n    }\n    \n    environment {\n        SNYK_TOKEN = credentials('snyk-token')\n        GITHUB_TOKEN = credentials('github-token')\n    }\n    \n    stages {\n        stage('Dependency Analysis') {\n            parallel {\n                stage('Node.js Dependencies') {\n                    steps {\n                        script {\n                            def packageDirs = sh(\n                                script: \"find . -name 'package.json' -not -path '*/node_modules/*' -exec dirname {} \\;\",\n                                returnStdout: true\n                            ).trim().split('\\n')\n                            \n                            packageDirs.each { dir ->\n                                dir(dir) {\n                                    sh '''\n                                        # Check for outdated packages\n                                        npm outdated --json > outdated.json || true\n                                        \n                                        # Security audit\n                                        npm audit --json > audit.json || true\n                                        \n                                        # Snyk vulnerability scan\n                                        npx snyk test --json > snyk.json || true\n                                        \n                                        # License compliance check\n                                        npx license-checker --json > licenses.json\n                                    '''\n                                    \n                                    archiveArtifacts '*.json'\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                stage('Python Dependencies') {\n                    steps {\n                        script {\n                            def requirementFiles = sh(\n                                script: \"find . -name 'requirements*.txt' -o -name 'Pipfile' -o -name 'pyproject.toml'\",\n                                returnStdout: true\n                            ).trim().split('\\n')\n                            \n                            requirementFiles.each { file ->\n                                def dir = sh(script: \"dirname ${file}\", returnStdout: true).trim()\n                                dir(dir) {\n                                    sh '''\n                                        python -m venv scan_venv\n                                        . scan_venv/bin/activate\n                                        \n                                        # Install dependencies\n                                        pip install -r requirements.txt || pip install -e .\n                                        \n                                        # Security scan\n                                        pip install safety\n                                        safety check --json --output safety.json || true\n                                        \n                                        # License scan\n                                        pip install pip-licenses\n                                        pip-licenses --format=json --output-file=licenses.json\n                                        \n                                        # Outdated packages\n                                        pip list --outdated --format=json > outdated.json\n                                        \n                                        rm -rf scan_venv\n                                    '''\n                                    \n                                    archiveArtifacts '*.json'\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                stage('Java Dependencies') {\n                    steps {\n                        script {\n                            def buildFiles = sh(\n                                script: \"find . -name 'pom.xml' -o -name 'build.gradle*'\",\n                                returnStdout: true\n                            ).trim().split('\\n')\n                            \n                            buildFiles.each { file ->\n                                def dir = sh(script: \"dirname ${file}\", returnStdout: true).trim()\n                                dir(dir) {\n                                    if (file.contains('pom.xml')) {\n                                        sh '''\n                                            # Maven dependency analysis\n                                            mvn dependency:tree -DoutputFile=dependency-tree.txt\n                                            mvn versions:display-dependency-updates -DoutputFile=updates.txt\n                                            \n                                            # OWASP dependency check\n                                            mvn org.owasp:dependency-check-maven:check -Dformat=JSON\n                                        '''\n                                    } else {\n                                        sh '''\n                                            # Gradle dependency analysis\n                                            ./gradlew dependencies > dependency-tree.txt\n                                            ./gradlew dependencyUpdates\n                                            \n                                            # OWASP dependency check\n                                            ./gradlew dependencyCheckAnalyze\n                                        '''\n                                    }\n                                    \n                                    archiveArtifacts 'dependency-tree.txt, updates.txt, target/dependency-check-report.json'\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Generate Security Report') {\n            steps {\n                script {\n                    sh '''\n                        # Aggregate all vulnerability reports\n                        python3 << 'EOF'\nimport json\nimport os\nfrom pathlib import Path\n\nvulnerabilities = []\nlicenses = []\noutdated = []\n\n# Collect all JSON reports\nfor json_file in Path('.').rglob('*.json'):\n    if 'audit.json' in str(json_file) or 'snyk.json' in str(json_file) or 'safety.json' in str(json_file):\n        with open(json_file) as f:\n            data = json.load(f)\n            vulnerabilities.append({\n                'file': str(json_file),\n                'data': data\n            })\n    elif 'licenses.json' in str(json_file):\n        with open(json_file) as f:\n            data = json.load(f)\n            licenses.extend(data if isinstance(data, list) else [data])\n    elif 'outdated.json' in str(json_file):\n        with open(json_file) as f:\n            data = json.load(f)\n            outdated.append({\n                'file': str(json_file),\n                'data': data\n            })\n\n# Generate consolidated report\nreport = {\n    'vulnerabilities': vulnerabilities,\n    'licenses': licenses,\n    'outdated': outdated,\n    'summary': {\n        'total_vulnerabilities': sum(len(v.get('data', {}).get('vulnerabilities', [])) for v in vulnerabilities),\n        'critical_vulnerabilities': 0,  # Calculate based on severity\n        'total_outdated': len(outdated),\n        'license_issues': []  # Check for problematic licenses\n    }\n}\n\nwith open('security-report.json', 'w') as f:\n    json.dump(report, f, indent=2)\nEOF\n                    '''\n                    \n                    archiveArtifacts 'security-report.json'\n                    \n                    // Create JIRA tickets for critical vulnerabilities\n                    script {\n                        def report = readJSON file: 'security-report.json'\n                        if (report.summary.total_vulnerabilities > 0) {\n                            jiraCreateIssue(\n                                site: 'company-jira',\n                                issue: [\n                                    fields: [\n                                        project: [key: 'SEC'],\n                                        summary: \"Security vulnerabilities found in dependencies\",\n                                        description: \"Found ${report.summary.total_vulnerabilities} vulnerabilities. Check build ${BUILD_URL}\",\n                                        issuetype: [name: 'Security Issue'],\n                                        priority: [name: 'High']\n                                    ]\n                                ]\n                            )\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Auto-Update Dependencies') {\n            when {\n                expression { params.AUTO_UPDATE == true }\n            }\n            steps {\n                script {\n                    // Create pull requests for dependency updates\n                    sh '''\n                        git config user.name \"Jenkins Bot\"\n                        git config user.email \"jenkins@company.com\"\n                        \n                        # Create update branch\n                        git checkout -b \"dependency-updates-${BUILD_NUMBER}\"\n                        \n                        # Update Node.js dependencies\n                        find . -name 'package.json' -not -path '*/node_modules/*' -exec dirname {} \\; | while read dir; do\n                            cd \"$dir\"\n                            npx npm-check-updates -u\n                            npm install\n                            cd - > /dev/null\n                        done\n                        \n                        # Update Python dependencies (be careful with major version changes)\n                        find . -name 'requirements.txt' -exec dirname {} \\; | while read dir; do\n                            cd \"$dir\"\n                            pip-compile --upgrade requirements.in\n                            cd - > /dev/null\n                        done\n                        \n                        # Commit changes\n                        git add .\n                        git commit -m \"chore: update dependencies [skip ci]\" || true\n                        \n                        # Push and create PR\n                        git push origin \"dependency-updates-${BUILD_NUMBER}\"\n                        \n                        # Create pull request using GitHub CLI\n                        gh pr create \\\n                          --title \"Automated dependency updates\" \\\n                          --body \"Automated dependency updates generated by Jenkins. Please review changes carefully.\" \\\n                          --head \"dependency-updates-${BUILD_NUMBER}\" \\\n                          --base main\n                    '''\n                }\n            }\n        }\n    }\n    \n    post {\n        always {\n            publishHTML([\n                allowMissing: false,\n                alwaysLinkToLastBuild: true,\n                keepAll: true,\n                reportDir: '.',\n                reportFiles: 'security-report.json',\n                reportName: 'Security Report'\n            ])\n        }\n        failure {\n            emailext(\n                subject: \"Dependency scan failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}\",\n                body: \"Dependency scanning pipeline failed. Check ${env.BUILD_URL}\",\n                to: \"security@company.com, devops@company.com\"\n            )\n        }\n    }\n}",
      "language": "groovy",
      "scenario": "Automated dependency scanning, vulnerability assessment, and dependency update pipeline"
    }
  ],
  "troubleshooting": [
    {
      "problem": "Build fails with out of memory errors",
      "solution": "Increase JVM heap size and optimize build parallelization",
      "commands": ["-Dorg.gradle.jvmargs='-Xmx4g'", "maven.opts=-Xmx2g"],
      "details": "Common in large projects. Monitor memory usage, use build caching, and consider splitting large builds."
    },
    {
      "problem": "Flaky tests causing build failures",
      "solution": "Implement test retry mechanisms and proper test isolation",
      "commands": ["testRetryGradle", "maven-surefire-plugin rerunFailingTestsCount"],
      "details": "Use test categorization, proper cleanup, and deterministic test data"
    },
    {
      "problem": "Slow build times",
      "solution": "Enable build caching, parallelize tasks, and optimize dependencies",
      "commands": ["--build-cache", "--parallel", "npm ci instead of npm install"],
      "details": "Profile builds, use incremental compilation, and consider build tool optimization"
    },
    {
      "problem": "Artifact upload failures",
      "solution": "Check network connectivity, credentials, and repository permissions",
      "commands": ["curl -I repository-url", "test credentials"],
      "details": "Verify repository availability, check disk space, and validate artifact formats"
    }
  ],
  "tags": ["build-automation", "testing", "artifacts", "deployment", "ci-cd", "optimization"]
}
