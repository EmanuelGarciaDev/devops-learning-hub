{
  "id": "inventory-management",
  "toolId": "ansible",
  "name": "Inventory Management",
  "description": "Master Ansible inventory management for organizing and targeting hosts across complex infrastructure environments",
  "difficulty": "intermediate",
  "definitions": {
    "beginner": "Ansible inventory is a collection of hosts and groups that defines which machines Ansible can manage. It can be a simple text file listing servers, or a dynamic system that discovers infrastructure automatically.",
    "advanced": "Ansible inventory management encompasses static INI/YAML files, dynamic inventory scripts, inventory plugins, group variables, host variables, variable precedence, patterns for host targeting, and integration with cloud providers, CMDB systems, and orchestration platforms for scalable infrastructure automation."
  },
  "commands": [
    {
      "command": "ansible-inventory",
      "description": "Display and manage inventory information",
      "example": "ansible-inventory --list -i inventory/",
      "flags": [
        {
          "flag": "--list",
          "description": "Output all hosts info in JSON format",
          "example": "--list"
        },
        {
          "flag": "--host",
          "description": "Output specific host info",
          "example": "--host web01.example.com"
        },
        {
          "flag": "--graph",
          "description": "Create inventory graph",
          "example": "--graph"
        },
        {
          "flag": "--vars",
          "description": "Add vars to graph display",
          "example": "--graph --vars"
        }
      ]
    },
    {
      "command": "ansible all -i inventory --list-hosts",
      "description": "List all hosts in inventory",
      "example": "ansible all -i production.ini --list-hosts"
    },
    {
      "command": "ansible-inventory --host hostname",
      "description": "Show variables for specific host",
      "example": "ansible-inventory --host web01 -i inventory/"
    }
  ],
  "examples": [
    {
      "title": "Comprehensive Multi-Environment Inventory Structure",
      "description": "Enterprise-grade inventory organization with multiple environments and dynamic groups",
      "code": "# inventory/production.yml - Production Environment Inventory\n---\nall:\n  children:\n    # Geographic regions\n    us_east:\n      children:\n        us_east_web:\n          hosts:\n            web01.us-east.example.com:\n              ansible_host: 10.1.1.10\n              ansible_user: ubuntu\n              server_id: web01\n              datacenter: us-east-1a\n            web02.us-east.example.com:\n              ansible_host: 10.1.1.11\n              ansible_user: ubuntu\n              server_id: web02\n              datacenter: us-east-1b\n            web03.us-east.example.com:\n              ansible_host: 10.1.1.12\n              ansible_user: ubuntu\n              server_id: web03\n              datacenter: us-east-1c\n        us_east_app:\n          hosts:\n            app01.us-east.example.com:\n              ansible_host: 10.1.2.10\n              app_profile: high_memory\n              jvm_heap: 4g\n            app02.us-east.example.com:\n              ansible_host: 10.1.2.11\n              app_profile: high_memory\n              jvm_heap: 4g\n        us_east_db:\n          hosts:\n            db01.us-east.example.com:\n              ansible_host: 10.1.3.10\n              mysql_role: master\n              backup_enabled: true\n            db02.us-east.example.com:\n              ansible_host: 10.1.3.11\n              mysql_role: slave\n              mysql_master: db01.us-east.example.com\n      vars:\n        region: us-east-1\n        environment: production\n        vpc_id: vpc-12345678\n        dns_zone: us-east.example.com\n    \n    us_west:\n      children:\n        us_west_web:\n          hosts:\n            web01.us-west.example.com:\n              ansible_host: 10.2.1.10\n              ansible_user: ubuntu\n              server_id: web01\n              datacenter: us-west-2a\n            web02.us-west.example.com:\n              ansible_host: 10.2.1.11\n              ansible_user: ubuntu\n              server_id: web02\n              datacenter: us-west-2b\n        us_west_app:\n          hosts:\n            app01.us-west.example.com:\n              ansible_host: 10.2.2.10\n              app_profile: standard\n              jvm_heap: 2g\n        us_west_db:\n          hosts:\n            db01.us-west.example.com:\n              ansible_host: 10.2.3.10\n              mysql_role: master\n              backup_enabled: true\n      vars:\n        region: us-west-2\n        environment: production\n        vpc_id: vpc-87654321\n        dns_zone: us-west.example.com\n    \n    # Service-based groups\n    webservers:\n      children:\n        - us_east_web\n        - us_west_web\n      vars:\n        nginx_worker_processes: auto\n        nginx_worker_connections: 1024\n        ssl_certificate_path: /etc/ssl/certs/example.com.crt\n        ssl_private_key_path: /etc/ssl/private/example.com.key\n        log_level: warn\n    \n    appservers:\n      children:\n        - us_east_app\n        - us_west_app\n      vars:\n        java_version: 11\n        tomcat_version: 9.0.50\n        app_port: 8080\n        monitoring_enabled: true\n        metrics_port: 9090\n    \n    databases:\n      children:\n        - us_east_db\n        - us_west_db\n      vars:\n        mysql_version: 8.0\n        innodb_buffer_pool_size: \"{{ (ansible_memtotal_mb * 0.6) | int }}M\"\n        mysql_max_connections: 200\n        slow_query_log: true\n        backup_retention_days: 30\n    \n    # Environment groups\n    production:\n      children:\n        - us_east\n        - us_west\n      vars:\n        monitoring_interval: 60\n        log_retention_days: 90\n        security_updates: auto\n        backup_schedule: \"0 2 * * *\"\n    \n    # Infrastructure groups\n    load_balancers:\n      hosts:\n        lb01.example.com:\n          ansible_host: 10.1.0.10\n          lb_algorithm: round_robin\n          health_check_interval: 30\n        lb02.example.com:\n          ansible_host: 10.2.0.10\n          lb_algorithm: least_conn\n          health_check_interval: 30\n      vars:\n        keepalived_enabled: true\n        ssl_termination: true\n    \n    monitoring:\n      hosts:\n        prometheus.example.com:\n          ansible_host: 10.0.1.10\n          prometheus_retention: 15d\n          prometheus_scrape_interval: 15s\n        grafana.example.com:\n          ansible_host: 10.0.1.11\n          grafana_admin_password: \"{{ vault_grafana_admin_password }}\"\n        alertmanager.example.com:\n          ansible_host: 10.0.1.12\n          smtp_server: smtp.example.com\n      vars:\n        monitoring_network: 10.0.1.0/24\n        data_retention_policy: 30d\n    \n    # Functional groups\n    masters:\n      hosts:\n        db01.us-east.example.com:\n        db01.us-west.example.com:\n      vars:\n        mysql_read_only: false\n        backup_priority: high\n    \n    slaves:\n      hosts:\n        db02.us-east.example.com:\n      vars:\n        mysql_read_only: true\n        backup_priority: low\n    \n    # Custom groups based on attributes\n    high_memory_servers:\n      hosts:\n        app01.us-east.example.com:\n        app02.us-east.example.com:\n      vars:\n        memory_profile: high\n        swap_disabled: true\n    \n    ssl_enabled:\n      children:\n        - webservers\n        - load_balancers\n      vars:\n        ssl_protocols: \"TLSv1.2 TLSv1.3\"\n        ssl_ciphers: \"ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512\"\n  \n  vars:\n    # Global variables\n    ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'\n    ansible_python_interpreter: /usr/bin/python3\n    company_name: \"Example Corp\"\n    support_email: \"ops@example.com\"\n    ntp_servers:\n      - 0.pool.ntp.org\n      - 1.pool.ntp.org\n      - 2.pool.ntp.org\n    dns_servers:\n      - 8.8.8.8\n      - 8.8.4.4\n    timezone: UTC\n    \n---\n# inventory/staging.yml - Staging Environment\nall:\n  children:\n    staging:\n      hosts:\n        web-staging.example.com:\n          ansible_host: 192.168.1.10\n          ansible_user: ubuntu\n        app-staging.example.com:\n          ansible_host: 192.168.1.11\n          ansible_user: ubuntu\n        db-staging.example.com:\n          ansible_host: 192.168.1.12\n          ansible_user: ubuntu\n          mysql_role: standalone\n      vars:\n        environment: staging\n        log_level: debug\n        backup_enabled: false\n        monitoring_interval: 300\n  \n  vars:\n    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'\n    ansible_python_interpreter: /usr/bin/python3\n\n---\n# group_vars/all.yml - Global Variables\n---\n# SSH Configuration\nansible_ssh_pipelining: true\nansible_ssh_retries: 3\n\n# Package management\npackage_update_cache_valid_time: 3600\npackage_upgrade: safe\n\n# Security settings\nfirewall_enabled: true\nfail2ban_enabled: true\nssh_password_authentication: false\nssh_permit_root_login: false\n\n# Monitoring\nnode_exporter_enabled: true\nlog_forwarding_enabled: true\nsyslog_server: \"{{ groups['monitoring'][0] if groups['monitoring'] is defined else 'localhost' }}\"\n\n# Backup configuration\nbackup_s3_bucket: \"company-backups-{{ environment }}\"\nbackup_encryption_enabled: true\n\n# Application defaults\napp_user: appuser\napp_group: appuser\napp_home: \"/opt/{{ app_name | default('application') }}\"\n\n---\n# group_vars/webservers.yml - Web Server Specific Variables\n---\nnginx_user: www-data\nnginx_worker_processes: \"{{ ansible_processor_vcpus }}\"\nnginx_worker_connections: 1024\nnginx_keepalive_timeout: 65\nnginx_client_max_body_size: 10m\n\n# SSL Configuration\nssl_session_cache: \"shared:SSL:10m\"\nssl_session_timeout: 10m\nssl_prefer_server_ciphers: true\n\n# Logging\naccess_log_format: 'combined'\nerror_log_level: warn\nlog_rotation_days: 30\n\n# Performance tuning\nopen_file_cache_max: 2000\nopen_file_cache_inactive: 20s\ngzip_enabled: true\ngzip_comp_level: 6\n\n---\n# group_vars/databases.yml - Database Specific Variables\n---\nmysql_bind_address: \"0.0.0.0\"\nmysql_port: 3306\nmysql_datadir: /var/lib/mysql\nmysql_socket: /var/run/mysqld/mysqld.sock\n\n# Performance settings\nmysql_key_buffer_size: 256M\nmysql_max_allowed_packet: 64M\nmysql_thread_stack: 256K\nmysql_thread_cache_size: 8\nmysql_query_cache_size: 32M\nmysql_query_cache_limit: 2M\n\n# InnoDB settings\nmysql_innodb_file_per_table: true\nmysql_innodb_log_file_size: 256M\nmysql_innodb_log_buffer_size: 8M\nmysql_innodb_flush_log_at_trx_commit: 1\n\n# Replication settings\nmysql_server_id: \"{{ 100 + groups['databases'].index(inventory_hostname) }}\"\nmysql_log_bin: mysql-bin\nmysql_expire_logs_days: 7\n\n# Backup settings\nmysql_backup_dir: /backup/mysql\nmysql_backup_compress: true\nmysql_backup_user: backup\nmysql_backup_password: \"{{ vault_mysql_backup_password }}\"\n\n---\n# host_vars/web01.us-east.example.com.yml - Host Specific Variables\n---\n# Custom configuration for specific host\nnginx_worker_processes: 4  # Override default\nssl_certificate_domain: web01.us-east.example.com\n\n# Monitoring specific to this host\ncustom_metrics_enabled: true\nprometheus_node_exporter_collectors:\n  - cpu\n  - diskstats\n  - filesystem\n  - loadavg\n  - meminfo\n  - netdev\n  - textfile\n\n# Backup configuration\nbackup_schedule: \"0 3 * * *\"\nbackup_priority: high\n\n# Network configuration\nnetwork_interfaces:\n  - name: eth0\n    address: 10.1.1.10\n    netmask: 255.255.255.0\n    gateway: 10.1.1.1\n  - name: eth1\n    address: 10.1.100.10\n    netmask: 255.255.255.0\n    purpose: backup_network",
      "language": "yaml",
      "scenario": "Enterprise multi-environment inventory with geographic distribution and service-based grouping"
    },
    {
      "title": "Dynamic AWS Inventory Plugin Configuration",
      "description": "AWS dynamic inventory with advanced filtering and grouping",
      "code": "# inventory/aws_ec2.yml - AWS Dynamic Inventory Plugin Configuration\n---\nplugin: amazon.aws.aws_ec2\n\n# AWS Connection\naws_access_key: \"{{ lookup('env', 'AWS_ACCESS_KEY_ID') }}\"\naws_secret_key: \"{{ lookup('env', 'AWS_SECRET_ACCESS_KEY') }}\"\nregions:\n  - us-east-1\n  - us-west-2\n  - eu-west-1\n\n# Instance filters\nfilters:\n  # Only running instances\n  instance-state-name: running\n  # Only instances with specific tags\n  \"tag:Environment\": [\"production\", \"staging\"]\n  \"tag:Managed\": [\"ansible\"]\n\n# Exclude instances\nexclude_filters:\n  - \"tag:Ignore\": [\"true\"]\n  - \"tag:Terminated\": [\"*\"]\n\n# Include/exclude by tags\ninclude_extra_api_calls: true\nuse_contrib_script_compatible_sanitization: false\n\n# Grouping configuration\nkeyed_groups:\n  # Group by instance type\n  - key: instance_type\n    prefix: type\n    separator: '_'\n  \n  # Group by availability zone\n  - key: placement.availability_zone\n    prefix: az\n    separator: '_'\n  \n  # Group by VPC\n  - key: vpc_id\n    prefix: vpc\n    separator: '_'\n  \n  # Group by environment tag\n  - key: tags.Environment\n    prefix: env\n    separator: '_'\n  \n  # Group by application tag\n  - key: tags.Application\n    prefix: app\n    separator: '_'\n  \n  # Group by role tag\n  - key: tags.Role\n    prefix: role\n    separator: '_'\n  \n  # Group by subnet\n  - key: subnet_id\n    prefix: subnet\n    separator: '_'\n  \n  # Group by security groups\n  - key: security_groups[].group_name\n    prefix: sg\n    separator: '_'\n  \n  # Custom grouping by cost center\n  - key: tags.CostCenter\n    prefix: cost_center\n    separator: '_'\n  \n  # Group by backup schedule\n  - key: tags.BackupSchedule\n    prefix: backup\n    separator: '_'\n\n# Conditional groups\ngroups:\n  # Production instances\n  production: tags.Environment == \"production\"\n  \n  # Staging instances  \n  staging: tags.Environment == \"staging\"\n  \n  # Web servers\n  webservers: tags.Role == \"webserver\"\n  \n  # Application servers\n  appservers: tags.Role == \"appserver\"\n  \n  # Database servers\n  databases: tags.Role == \"database\"\n  \n  # Load balancers\n  loadbalancers: tags.Role == \"loadbalancer\"\n  \n  # High availability instances\n  ha_instances: tags.HA == \"true\"\n  \n  # Instances with public IPs\n  public_instances: public_ip_address != \"\"\n  \n  # Instances in private subnets\n  private_instances: public_ip_address == \"\"\n  \n  # Large instances\n  large_instances: instance_type.startswith(\"m5.large\") or instance_type.startswith(\"c5.large\")\n  \n  # Instances requiring patching\n  patch_group_a: tags.PatchGroup == \"A\"\n  patch_group_b: tags.PatchGroup == \"B\"\n  \n  # Monitoring targets\n  monitoring_targets: tags.Monitoring == \"enabled\"\n  \n  # Backup targets\n  backup_targets: tags.Backup == \"enabled\"\n\n# Host variables composition\ncompose:\n  # Use private IP for ansible_host if no public IP\n  ansible_host: public_ip_address | default(private_ip_address)\n  \n  # Set ansible user based on AMI type\n  ansible_user: |\n    (\n      \"ubuntu\" if (image.name | default(\"\")).find(\"ubuntu\") != -1\n      else \"ec2-user\" if (image.name | default(\"\")).find(\"amzn\") != -1\n      else \"centos\" if (image.name | default(\"\")).find(\"centos\") != -1\n      else \"admin\"\n    )\n  \n  # Extract environment from tags\n  environment: tags.Environment | default(\"unknown\")\n  \n  # Extract application name\n  application: tags.Application | default(\"generic\")\n  \n  # Extract role\n  server_role: tags.Role | default(\"unspecified\")\n  \n  # Set backup schedule\n  backup_schedule: tags.BackupSchedule | default(\"none\")\n  \n  # Set monitoring status\n  monitoring_enabled: (tags.Monitoring | default(\"false\")) == \"true\"\n  \n  # Instance size category\n  instance_size: |\n    (\n      \"small\" if instance_type.endswith(\".micro\") or instance_type.endswith(\".small\")\n      else \"medium\" if instance_type.endswith(\".medium\") or instance_type.endswith(\".large\")\n      else \"large\"\n    )\n  \n  # Network zone\n  network_zone: |\n    (\n      \"public\" if public_ip_address != \"\"\n      else \"private\"\n    )\n  \n  # Custom facts from tags\n  cost_center: tags.CostCenter | default(\"unassigned\")\n  owner: tags.Owner | default(\"unspecified\")\n  project: tags.Project | default(\"default\")\n  \n  # Derived attributes\n  fqdn: \"{{ tags.Name | default(instance_id) }}.{{ tags.Domain | default('example.com') }}\"\n  short_name: tags.Name | default(instance_id)\n  \n  # Security and compliance\n  compliance_scope: tags.Compliance | default(\"standard\")\n  security_group_names: security_groups | map(attribute='group_name') | list\n  \n  # Performance and scaling\n  auto_scaling_group: tags['aws:autoscaling:groupName'] | default(\"none\")\n  launch_template: tags.LaunchTemplate | default(\"none\")\n\n# Cache settings\ncache: true\ncache_plugin: memory\ncache_timeout: 3600\ncache_connection: /tmp/ansible-aws-ec2-cache\n\n# Advanced options\nstrict_permissions: true\ninclude_filters: []\nhostnames:\n  - dns-name\n  - private-dns-name\n  - tag:Name\n  - instance-id\n\n---\n# inventory/plugins/custom_inventory.py - Custom Dynamic Inventory Script\n#!/usr/bin/env python3\n\"\"\"\nCustom Ansible Dynamic Inventory Script\nIntegrates with multiple data sources: CMDB, DNS, and cloud APIs\n\"\"\"\n\nimport json\nimport sys\nimport argparse\nimport requests\nimport dns.resolver\nimport boto3\nfrom typing import Dict, List, Any\n\nclass CustomInventory:\n    def __init__(self):\n        self.inventory = {\n            '_meta': {\n                'hostvars': {}\n            }\n        }\n        self.cmdb_url = \"https://cmdb.example.com/api/v1\"\n        self.dns_domain = \"example.com\"\n        \n    def get_cmdb_data(self) -> List[Dict]:\n        \"\"\"Fetch server data from CMDB\"\"\"\n        try:\n            response = requests.get(f\"{self.cmdb_url}/servers\", timeout=30)\n            response.raise_for_status()\n            return response.json()\n        except requests.RequestException as e:\n            print(f\"CMDB fetch error: {e}\", file=sys.stderr)\n            return []\n    \n    def get_aws_instances(self) -> List[Dict]:\n        \"\"\"Fetch AWS EC2 instances\"\"\"\n        try:\n            ec2 = boto3.client('ec2')\n            response = ec2.describe_instances(\n                Filters=[\n                    {'Name': 'instance-state-name', 'Values': ['running']},\n                    {'Name': 'tag:Managed', 'Values': ['ansible']}\n                ]\n            )\n            \n            instances = []\n            for reservation in response['Reservations']:\n                for instance in reservation['Instances']:\n                    instances.append(instance)\n            return instances\n        except Exception as e:\n            print(f\"AWS fetch error: {e}\", file=sys.stderr)\n            return []\n    \n    def resolve_dns(self, hostname: str) -> str:\n        \"\"\"Resolve hostname to IP address\"\"\"\n        try:\n            result = dns.resolver.resolve(hostname, 'A')\n            return str(result[0])\n        except Exception:\n            return hostname\n    \n    def add_host_to_group(self, group_name: str, hostname: str):\n        \"\"\"Add host to inventory group\"\"\"\n        if group_name not in self.inventory:\n            self.inventory[group_name] = {\n                'hosts': [],\n                'vars': {}\n            }\n        \n        if hostname not in self.inventory[group_name]['hosts']:\n            self.inventory[group_name]['hosts'].append(hostname)\n    \n    def set_host_vars(self, hostname: str, variables: Dict[str, Any]):\n        \"\"\"Set variables for a host\"\"\"\n        self.inventory['_meta']['hostvars'][hostname] = variables\n    \n    def process_cmdb_servers(self):\n        \"\"\"Process CMDB server data\"\"\"\n        servers = self.get_cmdb_data()\n        \n        for server in servers:\n            hostname = server.get('hostname', '')\n            if not hostname:\n                continue\n            \n            # Add to groups based on CMDB attributes\n            environment = server.get('environment', 'unknown')\n            role = server.get('role', 'generic')\n            location = server.get('location', 'unknown')\n            \n            # Create groups\n            self.add_host_to_group(f\"env_{environment}\", hostname)\n            self.add_host_to_group(f\"role_{role}\", hostname)\n            self.add_host_to_group(f\"location_{location}\", hostname)\n            self.add_host_to_group(\"cmdb_managed\", hostname)\n            \n            # Set host variables\n            host_vars = {\n                'ansible_host': self.resolve_dns(hostname),\n                'ansible_user': server.get('ssh_user', 'root'),\n                'environment': environment,\n                'server_role': role,\n                'location': location,\n                'cmdb_id': server.get('id'),\n                'owner': server.get('owner', 'unknown'),\n                'cost_center': server.get('cost_center', 'default'),\n                'backup_enabled': server.get('backup_enabled', False),\n                'monitoring_enabled': server.get('monitoring_enabled', True),\n                'os_family': server.get('os_family', 'linux'),\n                'cpu_cores': server.get('cpu_cores', 1),\n                'memory_gb': server.get('memory_gb', 1)\n            }\n            \n            # Add custom attributes\n            if server.get('custom_attributes'):\n                host_vars.update(server['custom_attributes'])\n            \n            self.set_host_vars(hostname, host_vars)\n    \n    def process_aws_instances(self):\n        \"\"\"Process AWS EC2 instances\"\"\"\n        instances = self.get_aws_instances()\n        \n        for instance in instances:\n            instance_id = instance['InstanceId']\n            \n            # Get instance name from tags\n            name_tag = next(\n                (tag['Value'] for tag in instance.get('Tags', []) \n                 if tag['Key'] == 'Name'), instance_id\n            )\n            \n            hostname = f\"{name_tag}.{self.dns_domain}\"\n            \n            # Extract tags for grouping\n            tags = {tag['Key']: tag['Value'] for tag in instance.get('Tags', [])}\n            \n            # Add to groups\n            environment = tags.get('Environment', 'unknown')\n            role = tags.get('Role', 'generic')\n            \n            self.add_host_to_group(f\"aws_{environment}\", hostname)\n            self.add_host_to_group(f\"aws_role_{role}\", hostname)\n            self.add_host_to_group(f\"aws_{instance['InstanceType']}\", hostname)\n            self.add_host_to_group(\"aws_managed\", hostname)\n            \n            # Set host variables\n            host_vars = {\n                'ansible_host': instance.get('PublicIpAddress', instance.get('PrivateIpAddress')),\n                'ansible_user': 'ubuntu' if 'ubuntu' in tags.get('AMI', '').lower() else 'ec2-user',\n                'instance_id': instance_id,\n                'instance_type': instance['InstanceType'],\n                'availability_zone': instance['Placement']['AvailabilityZone'],\n                'vpc_id': instance['VpcId'],\n                'subnet_id': instance['SubnetId'],\n                'private_ip': instance['PrivateIpAddress'],\n                'public_ip': instance.get('PublicIpAddress', ''),\n                'environment': environment,\n                'server_role': role,\n                'aws_tags': tags\n            }\n            \n            self.set_host_vars(hostname, host_vars)\n    \n    def generate_inventory(self) -> Dict[str, Any]:\n        \"\"\"Generate complete inventory\"\"\"\n        # Process all data sources\n        self.process_cmdb_servers()\n        self.process_aws_instances()\n        \n        # Add meta groups\n        all_hosts = []\n        for group_name, group_data in self.inventory.items():\n            if group_name != '_meta' and 'hosts' in group_data:\n                all_hosts.extend(group_data['hosts'])\n        \n        # Remove duplicates and create 'all' group\n        unique_hosts = list(set(all_hosts))\n        self.inventory['all'] = {\n            'hosts': unique_hosts,\n            'vars': {\n                'ansible_python_interpreter': '/usr/bin/python3',\n                'ansible_ssh_common_args': '-o StrictHostKeyChecking=no'\n            }\n        }\n        \n        return self.inventory\n    \n    def get_host_vars(self, hostname: str) -> Dict[str, Any]:\n        \"\"\"Get variables for specific host\"\"\"\n        self.generate_inventory()\n        return self.inventory['_meta']['hostvars'].get(hostname, {})\n\ndef main():\n    parser = argparse.ArgumentParser(description='Custom Ansible Dynamic Inventory')\n    parser.add_argument('--list', action='store_true', help='List all hosts')\n    parser.add_argument('--host', help='Get variables for specific host')\n    \n    args = parser.parse_args()\n    \n    inventory = CustomInventory()\n    \n    if args.list:\n        result = inventory.generate_inventory()\n        print(json.dumps(result, indent=2))\n    elif args.host:\n        result = inventory.get_host_vars(args.host)\n        print(json.dumps(result, indent=2))\n    else:\n        parser.print_help()\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()",
      "language": "python",
      "scenario": "Dynamic inventory integration with AWS, CMDB, and DNS for complex enterprise environments"
    },
    {
      "title": "Advanced Host Patterns and Targeting",
      "description": "Complex host targeting patterns for precise execution control",
      "code": "# Host Pattern Examples for ansible and ansible-playbook commands\n\n# Basic patterns\nansible all -m ping                              # All hosts\nansible webservers -m setup                      # All hosts in webservers group\nansible db01.example.com -m shell -a \"uptime\"    # Specific host\n\n# Wildcard patterns\nansible \"web*\" -m ping                           # All hosts starting with 'web'\nansible \"*.example.com\" -m ping                  # All hosts ending with '.example.com'\nansible \"web[01:05].example.com\" -m ping         # Hosts web01 through web05\nansible \"web[a:c].example.com\" -m ping           # Hosts weba, webb, webc\n\n# Group operations\nansible \"webservers:databases\" -m ping           # Hosts in webservers OR databases\nansible \"webservers:&databases\" -m ping          # Hosts in webservers AND databases\nansible \"webservers:!databases\" -m ping          # Hosts in webservers but NOT in databases\nansible \"all:!monitoring\" -m ping                # All hosts except monitoring group\n\n# Complex combinations\nansible \"webservers:&production:!maintenance\" -m ping  # Production webservers not in maintenance\nansible \"(webservers:databases):&production\" -m ping   # Production hosts that are web or db servers\nansible \"all:!~.*\\.staging\\..*\" -m ping              # All hosts not matching staging domain pattern\n\n# Regular expressions\nansible \"~web[0-9]+\\.prod\\..*\" -m ping            # Regex pattern for production web servers\nansible \"~.*\\.(dev|test)\\..*\" -m ping            # Development and test environments\n\n# Using variables in patterns\nansible \"{{ target_group | default('all') }}\" -m ping\n\n# Advanced inventory filtering with --limit\nansible-playbook site.yml --limit \"webservers:&production\"\nansible-playbook deploy.yml --limit \"@retry_hosts.txt\"        # From file\nansible-playbook update.yml --limit \"all:!critical_systems\"\n\n# Batch operations\nansible-playbook rolling_update.yml --limit \"webservers[0:2]\"  # First 3 web servers\nansible-playbook patching.yml --limit \"databases[::2]\"         # Every other database server\n\n---\n# inventory_patterns.yml - Playbook demonstrating advanced targeting\n---\n- name: Demonstrate Host Patterns\n  hosts: localhost\n  gather_facts: false\n  vars:\n    target_environments:\n      - production\n      - staging\n    maintenance_window: \"{{ maintenance_mode | default(false) }}\"\n  \n  tasks:\n    - name: Show all production web servers\n      debug:\n        msg: \"{{ groups['webservers'] | intersect(groups['production']) }}\"\n      when: \"'webservers' in groups and 'production' in groups\"\n    \n    - name: Show database servers not in maintenance\n      debug:\n        msg: \"{{ groups['databases'] | difference(groups.get('maintenance', [])) }}\"\n      when: \"'databases' in groups\"\n    \n    - name: Create dynamic host group\n      add_host:\n        name: \"{{ item }}\"\n        groups: \"dynamic_target\"\n      loop: \"{{ groups['all'] | select('match', '^web.*prod.*') | list }}\"\n    \n    - name: Target hosts by custom criteria\n      debug:\n        msg: \"Targeting {{ inventory_hostname }}\"\n      delegate_to: \"{{ item }}\"\n      loop: |\n        {%- set result = [] -%}\n        {%- for host in groups['all'] -%}\n          {%- set host_vars = hostvars[host] -%}\n          {%- if host_vars.get('environment') == 'production' and \n                 host_vars.get('server_role') in ['webserver', 'appserver'] and\n                 host_vars.get('maintenance_mode', false) == false -%}\n            {{- result.append(host) -}}\n          {%- endif -%}\n        {%- endfor -%}\n        {{ result }}\n\n---\n# Complex targeting in playbooks\n- name: Rolling Update with Complex Targeting\n  hosts: \"webservers:&production:!maintenance\"\n  serial: \"{{ batch_size | default(1) }}\"\n  max_fail_percentage: 10\n  gather_facts: true\n  \n  pre_tasks:\n    - name: Verify host is eligible for update\n      assert:\n        that:\n          - ansible_facts['distribution'] in ['Ubuntu', 'CentOS', 'RedHat']\n          - maintenance_mode | default(false) == false\n          - environment == 'production'\n        fail_msg: \"Host {{ inventory_hostname }} is not eligible for update\"\n    \n    - name: Check if host is in load balancer\n      uri:\n        url: \"http://{{ load_balancer_host }}/api/status/{{ inventory_hostname }}\"\n        method: GET\n      register: lb_status\n      delegate_to: localhost\n  \n  tasks:\n    - name: Remove from load balancer\n      uri:\n        url: \"http://{{ load_balancer_host }}/api/servers/{{ inventory_hostname }}/disable\"\n        method: POST\n      delegate_to: localhost\n      when: lb_status.json.enabled | default(false)\n    \n    - name: Wait for connections to drain\n      wait_for:\n        timeout: 30\n      when: lb_status.json.enabled | default(false)\n    \n    - name: Update packages\n      package:\n        name: \"*\"\n        state: latest\n      register: package_update\n    \n    - name: Restart services if needed\n      systemd:\n        name: \"{{ item }}\"\n        state: restarted\n      loop:\n        - nginx\n        - \"{{ app_service_name | default('myapp') }}\"\n      when: package_update.changed\n    \n    - name: Verify service health\n      uri:\n        url: \"http://{{ inventory_hostname }}:{{ app_port | default(80) }}/health\"\n        method: GET\n        status_code: 200\n      retries: 10\n      delay: 10\n  \n  post_tasks:\n    - name: Add back to load balancer\n      uri:\n        url: \"http://{{ load_balancer_host }}/api/servers/{{ inventory_hostname }}/enable\"\n        method: POST\n      delegate_to: localhost\n      when: lb_status.json.enabled | default(false)\n\n---\n# Environment-specific targeting\n- name: Environment-Specific Operations\n  hosts: \"{{ target_env | default('all') }}\"\n  gather_facts: false\n  \n  vars:\n    operation_matrix:\n      production:\n        backup_enabled: true\n        monitoring_level: full\n        update_schedule: maintenance_window\n      staging:\n        backup_enabled: false\n        monitoring_level: basic\n        update_schedule: anytime\n      development:\n        backup_enabled: false\n        monitoring_level: minimal\n        update_schedule: anytime\n  \n  tasks:\n    - name: Set environment-specific variables\n      set_fact:\n        env_config: \"{{ operation_matrix[environment] | default(operation_matrix['development']) }}\"\n    \n    - name: Apply environment-specific configuration\n      template:\n        src: \"{{ item }}.j2\"\n        dest: \"/etc/{{ item }}\"\n      loop:\n        - monitoring.conf\n        - backup.conf\n      when: env_config.backup_enabled or env_config.monitoring_level != 'minimal'\n    \n    - name: Schedule environment-appropriate updates\n      cron:\n        name: \"System updates\"\n        minute: \"0\"\n        hour: \"{{ '2' if env_config.update_schedule == 'maintenance_window' else '*/6' }}\"\n        job: \"/usr/bin/apt update && /usr/bin/apt upgrade -y\"\n        user: root\n      when: environment != 'production' or maintenance_window | default(false)\n\n# Using inventory patterns in configuration files\n---\n# ansible.cfg sections showing pattern usage\n[defaults]\nhost_key_checking = False\ninventory = inventory/\npattern = all:!disabled\n\n[inventory]\nenable_plugins = aws_ec2, yaml, ini\ncache = True\ncache_plugin = jsonfile\ncache_timeout = 3600\n\n# Custom facts for pattern matching\n---\n# roles/common/tasks/main.yml\n- name: Set custom facts for targeting\n  set_fact:\n    server_tier: |\n      {%- if 'webservers' in group_names -%}\n        frontend\n      {%- elif 'appservers' in group_names -%}\n        middle\n      {%- elif 'databases' in group_names -%}\n        backend\n      {%- else -%}\n        utility\n      {%- endif -%}\n    \n    criticality_level: |\n      {%- if environment == 'production' -%}\n        {%- if server_tier in ['frontend', 'backend'] -%}\n          critical\n        {%- else -%}\n          important\n        {%- endif -%}\n      {%- else -%}\n        standard\n      {%- endif -%}\n    \n    patching_group: |\n      {%- set hash = inventory_hostname | hash('md5') -%}\n      {%- set group_num = (hash | int(base=16)) % 4 -%}\n      {{ 'group_' + group_num | string }}\n\n- name: Create dynamic groups based on facts\n  group_by:\n    key: \"{{ item }}\"\n  loop:\n    - \"tier_{{ server_tier }}\"\n    - \"criticality_{{ criticality_level }}\"\n    - \"patch_{{ patching_group }}\"\n    - \"env_{{ environment }}_tier_{{ server_tier }}\"",
      "language": "yaml",
      "scenario": "Advanced host targeting and pattern matching for complex enterprise inventory management"
    }
  ],
  "troubleshooting": [
    {
      "problem": "Dynamic inventory script not returning expected hosts",
      "solution": "Verify script permissions, test script manually, check API credentials and network connectivity",
      "commands": ["chmod +x script.py", "python3 script.py --list", "ansible-inventory --list"],
      "details": "Ensure script is executable and returns valid JSON format with proper _meta structure"
    },
    {
      "problem": "Host variables not being applied correctly",
      "solution": "Check variable precedence and verify group_vars/host_vars file structure and naming",
      "commands": ["ansible-inventory --host hostname", "ansible-config dump"],
      "details": "Variable precedence: extra vars > host vars > group vars > inventory vars > defaults"
    },
    {
      "problem": "Inventory taking too long to load",
      "solution": "Enable inventory caching and optimize dynamic inventory scripts with filtering",
      "commands": ["ansible-inventory --list --export", "time ansible-inventory --graph"],
      "details": "Use cache plugins and limit API calls in dynamic inventory scripts"
    },
    {
      "problem": "Host patterns not matching expected hosts",
      "solution": "Test patterns with ansible command and verify group membership and naming",
      "commands": ["ansible 'pattern' --list-hosts", "ansible-inventory --graph"],
      "details": "Use single quotes around patterns and verify regex syntax for complex patterns"
    }
  ],
  "tags": ["inventory", "hosts", "groups", "targeting", "patterns", "dynamic", "aws", "organization"]
}
