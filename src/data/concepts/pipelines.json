{
  "id": "pipelines",
  "toolId": "jenkins",
  "name": "Jenkins Pipelines",
  "description": "Declarative and scripted pipeline creation for advanced CI/CD workflows",
  "difficulty": "intermediate",
  "definitions": {
    "beginner": "Jenkins Pipelines are automated workflows that define your entire CI/CD process as code, allowing you to build, test, and deploy applications automatically through a series of connected stages.",
    "advanced": "Jenkins Pipelines implement CI/CD as code using Groovy-based DSL with two syntaxes: Declarative (structured, recommended) and Scripted (imperative, flexible). Pipelines support parallel execution, matrix builds, conditional logic, shared libraries, and integration with external systems through extensive plugin ecosystem."
  },
  "commands": [
    {
      "command": "pipeline script validation",
      "description": "Validate pipeline syntax in Jenkins UI",
      "example": "Declarative Directive Generator → Pipeline Syntax"
    }
  ],
  "examples": [
    {
      "title": "Complete Declarative Pipeline",
      "description": "Production-ready pipeline with multiple stages, parallel execution, and post-actions",
      "code": "pipeline {\n    agent {\n        kubernetes {\n            yaml \"\"\"\n                apiVersion: v1\n                kind: Pod\n                spec:\n                  containers:\n                  - name: maven\n                    image: maven:3.8.4-openjdk-11\n                    command:\n                    - cat\n                    tty: true\n                  - name: docker\n                    image: docker:20.10.12-dind\n                    securityContext:\n                      privileged: true\n            \"\"\"\n        }\n    }\n    \n    environment {\n        DOCKER_REGISTRY = 'your-registry.com'\n        APP_NAME = 'my-spring-app'\n        DOCKER_CREDENTIALS = credentials('docker-hub-credentials')\n        SONAR_TOKEN = credentials('sonar-token')\n    }\n    \n    triggers {\n        pollSCM('H/5 * * * *')  // Poll every 5 minutes\n        cron('H 2 * * 1-5')     // Nightly build weekdays\n    }\n    \n    parameters {\n        choice(\n            name: 'ENVIRONMENT',\n            choices: ['dev', 'staging', 'prod'],\n            description: 'Target environment'\n        )\n        booleanParam(\n            name: 'SKIP_TESTS',\n            defaultValue: false,\n            description: 'Skip test execution'\n        )\n    }\n    \n    stages {\n        stage('Checkout') {\n            steps {\n                checkout scm\n                script {\n                    env.GIT_COMMIT_SHORT = sh(\n                        script: \"git rev-parse --short HEAD\",\n                        returnStdout: true\n                    ).trim()\n                    env.BUILD_VERSION = \"${env.BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}\"\n                }\n            }\n        }\n        \n        stage('Build & Test') {\n            parallel {\n                stage('Maven Build') {\n                    when {\n                        not { params.SKIP_TESTS }\n                    }\n                    steps {\n                        container('maven') {\n                            sh '''\n                                mvn clean compile\n                                mvn test -Dmaven.test.failure.ignore=true\n                                mvn package -DskipTests\n                            '''\n                        }\n                    }\n                    post {\n                        always {\n                            junit 'target/surefire-reports/*.xml'\n                            publishHTML([\n                                allowMissing: false,\n                                alwaysLinkToLastBuild: true,\n                                keepAll: true,\n                                reportDir: 'target/site/jacoco',\n                                reportFiles: 'index.html',\n                                reportName: 'Coverage Report'\n                            ])\n                        }\n                    }\n                }\n                \n                stage('Code Quality') {\n                    steps {\n                        container('maven') {\n                            script {\n                                withSonarQubeEnv('SonarQube') {\n                                    sh '''\n                                        mvn sonar:sonar \\\n                                          -Dsonar.projectKey=${APP_NAME} \\\n                                          -Dsonar.host.url=${SONAR_HOST_URL} \\\n                                          -Dsonar.login=${SONAR_TOKEN}\n                                    '''\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                stage('Security Scan') {\n                    steps {\n                        container('maven') {\n                            sh '''\n                                # OWASP Dependency Check\n                                mvn org.owasp:dependency-check-maven:check\n                                \n                                # Trivy filesystem scan\n                                curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin\n                                trivy fs --security-checks vuln,config .\n                            '''\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Quality Gate') {\n            steps {\n                script {\n                    timeout(time: 5, unit: 'MINUTES') {\n                        def qg = waitForQualityGate()\n                        if (qg.status != 'OK') {\n                            error \"Pipeline aborted due to quality gate failure: ${qg.status}\"\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Docker Build') {\n            steps {\n                container('docker') {\n                    script {\n                        def image = docker.build(\"${DOCKER_REGISTRY}/${APP_NAME}:${BUILD_VERSION}\")\n                        \n                        docker.withRegistry(\"https://${DOCKER_REGISTRY}\", 'docker-hub-credentials') {\n                            image.push()\n                            image.push('latest')\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Deploy') {\n            when {\n                anyOf {\n                    branch 'main'\n                    branch 'develop'\n                    expression { params.ENVIRONMENT == 'prod' }\n                }\n            }\n            steps {\n                script {\n                    switch(params.ENVIRONMENT) {\n                        case 'dev':\n                            deployToEnvironment('dev', env.BUILD_VERSION)\n                            break\n                        case 'staging':\n                            deployToEnvironment('staging', env.BUILD_VERSION)\n                            runSmokeTests('staging')\n                            break\n                        case 'prod':\n                            input message: 'Deploy to Production?', ok: 'Deploy',\n                                  submitterParameter: 'APPROVER'\n                            deployToEnvironment('prod', env.BUILD_VERSION)\n                            runSmokeTests('prod')\n                            break\n                    }\n                }\n            }\n        }\n    }\n    \n    post {\n        always {\n            script {\n                // Cleanup\n                sh 'docker system prune -f || true'\n                \n                // Archive artifacts\n                archiveArtifacts artifacts: 'target/*.jar', allowEmptyArchive: true\n                \n                // Publish test results\n                publishTestResults testResultsPattern: 'target/surefire-reports/*.xml'\n            }\n        }\n        success {\n            script {\n                slackSend(\n                    channel: '#deployments',\n                    color: 'good',\n                    message: \"✅ ${env.JOB_NAME} - Build #${env.BUILD_NUMBER} succeeded\\n\" +\n                            \"Environment: ${params.ENVIRONMENT}\\n\" +\n                            \"Version: ${env.BUILD_VERSION}\\n\" +\n                            \"Changes: ${env.BUILD_URL}changes\"\n                )\n            }\n        }\n        failure {\n            script {\n                slackSend(\n                    channel: '#deployments',\n                    color: 'danger',\n                    message: \"❌ ${env.JOB_NAME} - Build #${env.BUILD_NUMBER} failed\\n\" +\n                            \"Environment: ${params.ENVIRONMENT}\\n\" +\n                            \"Log: ${env.BUILD_URL}console\"\n                )\n                \n                // Create JIRA ticket for failures in main branch\n                if (env.BRANCH_NAME == 'main') {\n                    jiraCreateIssue(\n                        site: 'your-jira-site',\n                        issue: [\n                            fields: [\n                                project: [key: 'DEVOPS'],\n                                summary: \"Pipeline failure: ${env.JOB_NAME} #${env.BUILD_NUMBER}\",\n                                description: \"Build failed. Check: ${env.BUILD_URL}\",\n                                issuetype: [name: 'Bug'],\n                                priority: [name: 'High']\n                            ]\n                        ]\n                    )\n                }\n            }\n        }\n        unstable {\n            emailext(\n                subject: \"Unstable: ${env.JOB_NAME} - Build #${env.BUILD_NUMBER}\",\n                body: \"The build is unstable. Please check the test results.\",\n                to: \"${env.CHANGE_AUTHOR_EMAIL}, devops@company.com\"\n            )\n        }\n    }\n}\n\n// Helper functions\ndef deployToEnvironment(environment, version) {\n    withKubeConfig([credentialsId: \"k8s-${environment}-config\"]) {\n        sh \"\"\"\n            helm upgrade --install ${APP_NAME} ./helm-chart \\\n              --namespace ${environment} \\\n              --set image.tag=${version} \\\n              --set environment=${environment} \\\n              --wait --timeout=300s\n        \"\"\"\n    }\n}\n\ndef runSmokeTests(environment) {\n    script {\n        def response = httpRequest(\n            url: \"https://${APP_NAME}-${environment}.company.com/health\",\n            validResponseCodes: '200'\n        )\n        echo \"Health check passed: ${response.status}\"\n    }\n}",
      "language": "groovy",
      "scenario": "Enterprise-grade pipeline with parallel stages, quality gates, security scanning, and multi-environment deployment"
    },
    {
      "title": "Matrix Build Pipeline",
      "description": "Test across multiple environments and versions simultaneously",
      "code": "pipeline {\n    agent none\n    \n    stages {\n        stage('Matrix Build') {\n            matrix {\n                axes {\n                    axis {\n                        name 'JAVA_VERSION'\n                        values '11', '17', '21'\n                    }\n                    axis {\n                        name 'OS'\n                        values 'linux', 'windows'\n                    }\n                }\n                excludes {\n                    exclude {\n                        axis {\n                            name 'JAVA_VERSION'\n                            values '21'\n                        }\n                        axis {\n                            name 'OS'\n                            values 'windows'\n                        }\n                    }\n                }\n                stages {\n                    stage('Build') {\n                        agent {\n                            label \"${OS}\"\n                        }\n                        steps {\n                            script {\n                                if (OS == 'windows') {\n                                    bat \"\"\"\n                                        .\\mvnw.cmd clean test -Djava.version=${JAVA_VERSION}\n                                    \"\"\"\n                                } else {\n                                    sh \"\"\"\n                                        ./mvnw clean test -Djava.version=${JAVA_VERSION}\n                                    \"\"\"\n                                }\n                            }\n                        }\n                        post {\n                            always {\n                                junit 'target/surefire-reports/*.xml'\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
      "language": "groovy",
      "scenario": "Testing application compatibility across multiple Java versions and operating systems"
    },
    {
      "title": "Scripted Pipeline with Dynamic Stages",
      "description": "Advanced scripted pipeline with dynamic stage generation",
      "code": "node {\n    def microservices = ['user-service', 'order-service', 'payment-service', 'notification-service']\n    def parallelStages = [:]\n    \n    stage('Checkout') {\n        checkout scm\n        \n        // Determine changed services\n        def changedServices = []\n        if (env.CHANGE_ID) {\n            def changes = sh(\n                script: \"git diff --name-only origin/${env.CHANGE_TARGET} HEAD\",\n                returnStdout: true\n            ).trim().split('\\n')\n            \n            microservices.each { service ->\n                if (changes.any { it.startsWith(\"${service}/\") }) {\n                    changedServices.add(service)\n                }\n            }\n        } else {\n            changedServices = microservices\n        }\n        \n        echo \"Changed services: ${changedServices}\"\n        env.CHANGED_SERVICES = changedServices.join(',')\n    }\n    \n    stage('Build Changed Services') {\n        if (env.CHANGED_SERVICES) {\n            def services = env.CHANGED_SERVICES.split(',')\n            \n            services.each { service ->\n                parallelStages[\"build-${service}\"] = {\n                    node {\n                        dir(service) {\n                            stage(\"Build ${service}\") {\n                                sh \"\"\"\n                                    mvn clean package -DskipTests\n                                    docker build -t ${service}:${BUILD_NUMBER} .\n                                \"\"\"\n                            }\n                            \n                            stage(\"Test ${service}\") {\n                                parallel(\n                                    \"Unit Tests\": {\n                                        sh \"mvn test\"\n                                        junit 'target/surefire-reports/*.xml'\n                                    },\n                                    \"Integration Tests\": {\n                                        sh \"mvn verify -Pintegration-tests\"\n                                    },\n                                    \"Contract Tests\": {\n                                        sh \"mvn verify -Pcontract-tests\"\n                                    }\n                                )\n                            }\n                            \n                            stage(\"Security Scan ${service}\") {\n                                sh \"\"\"\n                                    # Container security scan\n                                    trivy image ${service}:${BUILD_NUMBER}\n                                    \n                                    # Code security scan\n                                    bandit -r src/ -f json -o security-report.json || true\n                                \"\"\"\n                                archiveArtifacts 'security-report.json'\n                            }\n                        }\n                    }\n                }\n            }\n            \n            parallel parallelStages\n        }\n    }\n    \n    stage('Integration Testing') {\n        if (env.CHANGED_SERVICES) {\n            // Deploy to test environment\n            sh \"\"\"\n                docker-compose -f docker-compose.test.yml up -d\n                sleep 30  # Wait for services to start\n            \"\"\"\n            \n            try {\n                // Run end-to-end tests\n                sh \"\"\"\n                    newman run postman/collection.json \\\n                      --environment postman/test-environment.json \\\n                      --reporters cli,junit \\\n                      --reporter-junit-export newman-results.xml\n                \"\"\"\n                \n                // Performance tests\n                sh \"\"\"\n                    k6 run --out junit=k6-results.xml performance-tests/load-test.js\n                \"\"\"\n            } finally {\n                sh \"docker-compose -f docker-compose.test.yml down\"\n                junit 'newman-results.xml, k6-results.xml'\n            }\n        }\n    }\n    \n    stage('Deploy to Staging') {\n        when {\n            branch 'develop'\n        }\n        \n        def services = env.CHANGED_SERVICES.split(',')\n        def deploymentStages = [:]\n        \n        services.each { service ->\n            deploymentStages[\"deploy-${service}\"] = {\n                sh \"\"\"\n                    kubectl set image deployment/${service} \\\n                      ${service}=${service}:${BUILD_NUMBER} \\\n                      -n staging\n                    \n                    kubectl rollout status deployment/${service} -n staging\n                \"\"\"\n            }\n        }\n        \n        parallel deploymentStages\n    }\n    \n    stage('Smoke Tests') {\n        script {\n            def services = env.CHANGED_SERVICES.split(',')\n            \n            services.each { service ->\n                retry(3) {\n                    sh \"\"\"\n                        curl -f https://${service}-staging.company.com/health || exit 1\n                    \"\"\"\n                }\n            }\n        }\n    }\n}",
      "language": "groovy",
      "scenario": "Microservices pipeline that only builds and deploys changed services"
    }
  ],
  "troubleshooting": [
    {
      "problem": "Pipeline fails with 'WorkflowScript: Loading failed'",
      "solution": "Check Groovy syntax using Pipeline Syntax validator",
      "commands": ["Pipeline Syntax → Snippet Generator"],
      "details": "Common causes: missing quotes, incorrect indentation, undefined variables"
    },
    {
      "problem": "Agent not found or offline",
      "solution": "Verify agent labels and node availability",
      "commands": ["Manage Jenkins → Manage Nodes"],
      "details": "Check agent connection, labels, and resource constraints"
    },
    {
      "problem": "Credentials not found in pipeline",
      "solution": "Verify credential ID and scope",
      "commands": ["Manage Jenkins → Manage Credentials"],
      "details": "Ensure credential ID matches exactly and has correct scope (Global/System)"
    },
    {
      "problem": "Pipeline stuck in queue",
      "solution": "Check executor availability and resource limits",
      "commands": ["Build Queue → Why is my build stuck?"],
      "details": "Common causes: no available executors, resource constraints, waiting for workspace"
    }
  ],
  "tags": ["pipelines", "declarative", "scripted", "groovy", "automation", "ci-cd"]
}
